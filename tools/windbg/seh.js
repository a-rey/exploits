"use strict";

// ----------------------------------------------------------------------------
// module helper functions
// ----------------------------------------------------------------------------

function Utils() {
  let _ = this;

  _.assert = function (condition) {
    // log error
    if (!condition) {
      let _e = new Error();
      host.diagnostics.debugLog(`[-] script failed assertion\r\n`);
      host.diagnostics.debugLog(`${_e.stack}\r\n`);
      throw _e;
    }
  }

  _.typeOf = function (obj) {
    return ({}).toString.call(obj).match(/\s(\w+)/)[1].toLowerCase();
  }

  _.log = function (msg) {
    _.assert(_.typeOf(msg) === 'string');
    host.diagnostics.debugLog(`${msg}\r\n`);
  }

  _.exec = function (cmd) {
    _.assert(_.typeOf(cmd) === 'string');
    _.log(`[*] EXEC: ${cmd}`);
    return host.namespace.Debugger.Utility.Control.ExecuteCommand(cmd);
  }

  _.is64bit = function () {
    return (host.namespace.Debugger.State.PseudoRegisters.General.ptrsize === 8);
  }

  _.padHex = function (strHex, width) {
    _.assert(_.typeOf(strHex) === 'string');
    if (!width) {
      width = (_.is64bit()) ? 16 : 8;
    }
    _.assert(_.typeOf(width) === 'number');
    let fmt = "0".repeat(width);
    return (fmt + strHex).substr(-1 * width);
  }

  _.toHex = function (num, width) {
    _.assert(_.typeOf(num) === 'number');
    return _.padHex((+num).toString(16), width);
  }

  _.toBytes = function (strHex, width) {
    _.assert(_.typeOf(strHex) === 'string');
    if (!width) {
      width = (_.is64bit()) ? 16 : 8;
    }
    _.assert(_.typeOf(width) === 'number');
    let _bytes = ("0".repeat(width) + strHex).substr(-1 * width).match(/..?/g);
    let _result = [];
    for (var i = 0; i < _bytes.length; i++) {
      if (!isNaN(Number('0x' + _bytes[i]))) {
        _result.push(parseInt(_bytes[i], 16));
      }
    }
    return _result;
  }

  _.sizeof = function (type) {
    _.assert(_.typeOf(type) === 'string');
    let _line = _.exec(`?? sizeof(${type})`)[0].split(" ");
    _.assert(_line.length === 3);
    return host.parseInt64(_line[2]);
  }

  _.readMemory = function (addr, numBytes) {
    _.assert(_.typeOf(addr)     === 'number');
    _.assert(_.typeOf(numBytes) === 'number');
    return host.memory.readMemoryValues(addr, 1, numBytes)[0];
  }

  _.searchMemory = function (start, end, bytes) {
    _.assert(_.typeOf(start) === 'number');
    _.assert(_.typeOf(end)   === 'number');
    _.assert(_.typeOf(bytes) === 'array');
    let _stringBytes = [];
    for (var i = 0; i < bytes.length; i++) {
      _.assert(_.typeOf(bytes[i]) === 'number');
      _stringBytes.push("0x" + _.toHex(bytes[i], 2));
    }
    let _cmd = `s -b ${_.toHex(start)} ${_.toHex(end)} ${_stringBytes.join(" ")}`;
    let _lines = [];
    for (let _line of _.exec(_cmd)) {
      if (_line.length === 0) {
        continue;
      }
      _lines.push(_line);
    }
    return _lines;
  }
}
let UTIL = new Utils();

// ----------------------------------------------------------------------------
// module routine
// ----------------------------------------------------------------------------

function SEH(moduleName, badBytes) {

  // --------------------------------------------------------------------------
  // gadget searching helpers
  // --------------------------------------------------------------------------

  // POP;POP;RET gadgets
  let PPR_GADGETS = [
    {
      "opcode": [0x58],
      "gadget": "POP EAX",
    },
    {
      "opcode": [0x5B],
      "gadget": "POP EBX",
    },
    {
      "opcode": [0x59],
      "gadget": "POP ECX",
    },
    {
      "opcode": [0x5E],
      "gadget": "POP ESI",
    },
    {
      "opcode": [0x5F],
      "gadget": "POP EDI",
    },
    {
      "opcode": [0x5D],
      "gadget": "POP EBP",
    },
  ];

  // POPAD;CALL/JMP gadgets
  let POPAD_GADGETS = [
    {
      "opcode": [0x61, 0xFF, 0xD5],
      "gadget": "POPAD; CALL EBP",
    },
    {
      "opcode": [0x61, 0xFF, 0xE5],
      "gadget": "POPAD; JMP EBP",
    },
    {
      "opcode": [0x61, 0xFF, 0xD0],
      "gadget": "POPAD; CALL EAX",
    },
    {
      "opcode": [0x61, 0xFF, 0xE0],
      "gadget": "POPAD; JMP EAX",
    },
  ];

  // CALL/JMP DWORD [EBP/ESP + 0x??] gadgets
  let DWORD_GADGETS = [
    {
      "opcode": [0xFF, 0x54, 0x24],
      "gadget": "CALL DWORD [ESP + ", // 0x??]
    },
    {
      "opcode": [0xFF, 0x55],
      "gadget": "CALL DWORD [EBP + ", // 0x??]
    },
    {
      "opcode": [0xFF, 0x64, 0x24],
      "gadget": "JMP DWORD [ESP + ", // 0x??]
    },
    {
      "opcode": [0xFF, 0x65],
      "gadget": "JMP DWORD [EBP + ", // 0x??]
    },
  ];

  function hasBadBytes(address, badBytes) {
    UTIL.assert(UTIL.typeOf(address)  === 'string');
    UTIL.assert(UTIL.typeOf(badBytes) === 'array');

    let _addrBytes = UTIL.toBytes(address);
    UTIL.assert(UTIL.typeOf(_addrBytes) === 'array');
    // loop through address bytes and check for bad bytes
    for (var i = 0; i < _addrBytes.length; i++) {
      for (var j = 0; j < badBytes.length; j++) {
        UTIL.assert(UTIL.typeOf(_addrBytes[i]) === 'number');
        UTIL.assert(UTIL.typeOf(badBytes[j])   === 'number');
        if (_addrBytes[i] === badBytes[j]) {
          return true;
        }
      }
    }
    return false;
  }

  function findGadgets(startAddress, endAddress, badBytes) {
    let _results = [];

    UTIL.assert(UTIL.typeOf(startAddress) === 'number');
    UTIL.assert(UTIL.typeOf(endAddress)   === 'number');
    UTIL.assert(UTIL.typeOf(badBytes)     === 'array');

    // search for a POP;POP;RET in the module memory
    for (var i = 0; i < PPR_GADGETS.length; i++) {
      for (var j = 0; j < PPR_GADGETS.length; j++) {
        let _opcodes = [].concat(PPR_GADGETS[i]['opcode'], PPR_GADGETS[j]['opcode'], [0xC3]); // 0xC3 = RET
        let _lines = UTIL.searchMemory(startAddress, endAddress, _opcodes);
        for (var k = 0; k < _lines.length; k++) {
          // sanity check there were results
          if (_lines[k].length === 0) {
            continue;
          }
          let _address = _lines[k].split(' ')[0];
          // check for bad bytes in address
          if (hasBadBytes(_address, _badBytesArray)) {
            continue;
          }
          // remember the result
          _results.push({
            "address" : "0x" + UTIL.padHex(_address),
            "gadget"  : `${PPR_GADGETS[i]['gadget']}; ${PPR_GADGETS[j]['gadget']}; RET;`
          });
        }
      }
    }

    // search for a CALL/JMP DWORD [EBP/ESP + 0x??] in the module memory
    // NOTE: max searched offset is 0x50 starting at 4 and going up by 4 bytes
    for (var i = 0; i < DWORD_GADGETS.length; i++) {
      for (var j = 0x04; j <= 0x50; j+=0x04) {
        let _opcodes = [].concat(DWORD_GADGETS[i]['opcode'], [j]);
        let _lines = UTIL.searchMemory(startAddress, endAddress, _opcodes);
        for (var k = 0; k < _lines.length; k++) {
          // sanity check there were results
          if (_lines[k].length === 0) {
            continue;
          }
          let _address = _lines[k].split(' ')[0];
          // check for bad bytes in address
          if (hasBadBytes(_address, _badBytesArray)) {
            continue;
          }
          // remember the result
          _results.push({
            "address" : "0x" + UTIL.padHex(_address),
            "gadget"  : `${DWORD_GADGETS[i]['gadget']}${UTIL.toHex(j, 2)}]`
          });
        }
      }
    }

    // search for a POPAD;JMP/CALL in the module memory
    for (var i = 0; i < POPAD_GADGETS.length; i++) {
      let _lines = UTIL.searchMemory(startAddress, endAddress, POPAD_GADGETS[i]['opcode']);
      for (var j = 0; j < _lines.length; j++) {
        // sanity check there were results
        if (_lines[j].length === 0) {
          continue;
        }
        let _address = _lines[j].split(' ')[0];
        // check for bad bytes in address
        if (hasBadBytes(_address, _badBytesArray)) {
          continue;
        }
        // remember the result
        _results.push({
          "address" : "0x" + UTIL.padHex(_address),
          "gadget"  : POPAD_GADGETS[i]['gadget'],
        });
      }
    }

    return _results;
  }

  // --------------------------------------------------------------------------
  // module routine
  // --------------------------------------------------------------------------

  // check module name argument
  if (!moduleName) {
    UTIL.log('[-] missing module name argument');
    return;
  }
  UTIL.assert(UTIL.typeOf(moduleName) === 'string');

  // check if bad bytes list is given and parse it
  let _badBytesArray = [];
  if (badBytes) {
    UTIL.log(`[*] received bad bytes list. attempting to parse ...`);
    UTIL.assert(UTIL.typeOf(badBytes) === 'string');
    try {
      let _hexChars = badBytes.split(',');
      for (var i = 0; i < _hexChars.length; i++) {
        // make sure the bytes are integers
        UTIL.assert(!isNaN(Number('0x' + _hexChars[i])));
        _badBytesArray.push(parseInt(_hexChars[i], 16));
        UTIL.log(`[*] --> parsed bad byte: ${"0x" + UTIL.toHex(parseInt(_hexChars[i], 16), 2)}`);
      }
      UTIL.log('[+] bad bytes list parsed successfully');
    } catch (err) {
      UTIL.log(`[-] failed to parse list. expecting something like 00,0A,76,69 and got ${badBytes}?`);
      return;
    }
  }

  // get PEB from pesudo-register
  let _peb = host.namespace.Debugger.State.PseudoRegisters.General.peb;

  // create an iterator for PEB->Ldr->InLoadOrderModuleList
  // https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb
  // https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data
  let _modules = host.namespace.Debugger.Utility.Collections.FromListEntry(
    _peb.Ldr.InLoadOrderModuleList,
    "ntdll!_LDR_DATA_TABLE_ENTRY",
    "InLoadOrderLinks"
  );

  // loop through each module and see if it is the one requested
  let _targetModule = undefined;
  for (let _dll of _modules) {
    // split the path and get the filename at the end
    let dllName = host.memory.readWideString(_dll.FullDllName.Buffer.address).split('\\').slice(-1)[0];
    if (dllName.toLowerCase() === moduleName.toLowerCase()) {
      UTIL.log(`[+] found target module ${dllName}`);
      _targetModule = _dll;
      break;
    }
  }

  // check for a match
  if (!_targetModule) {
    UTIL.log(`[-] failed to find module "${moduleName}"`);
    return;
  }

  // get module start and end addresses
  let _startAddress = parseInt(_targetModule.DllBase.address);
  let _endAddress   = parseInt(_targetModule.DllBase.address) + parseInt(_targetModule.SizeOfImage);
  UTIL.assert(!isNaN(_startAddress));
  UTIL.assert(!isNaN(_endAddress));
  UTIL.log(`[*] searching ${moduleName} from 0x${UTIL.toHex(_startAddress)} to 0x${UTIL.toHex(_endAddress)} ...`);

  let _results = findGadgets(_startAddress, _endAddress, _badBytesArray);

  // display results
  for (var i = 0; i < _results.length; i++) {
    UTIL.log(`${_results[i]["address"]} | ${_results[i]["gadget"]}`);
  }
  UTIL.log(`\n[+] found ${_results.length} gadgets`);
}

// ----------------------------------------------------------------------------
// module install
// ----------------------------------------------------------------------------

function initializeScript() {
  UTIL.log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
  UTIL.log("[+] loading module ...");
  var _cmds = [
    new host.functionAlias(
      SEH,
      "seh"
    ),
  ]; 
  UTIL.log("[+] run module as follows:\n");
  UTIL.log('!seh("<module name>","<bad bytes>")\n');
  UTIL.log("[+] examples:\n");
  UTIL.log('!seh("libtarget.dll")');
  UTIL.log('!seh("libspp.dll","00,02,0A,0D")\n');
  UTIL.log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
  return _cmds;
}
