"use strict";

const log = msg => host.diagnostics.debugLog(`${msg}\r\n`);

function *CheckSec() {

  // --------------------------------------------------------------------------
  // module internal functions
  // --------------------------------------------------------------------------

  function is64bit() {
    return (host.namespace.Debugger.State.PseudoRegisters.General.ptrsize === 8);
  }

  function readMemory(addr, numBytes) {
    return host.memory.readMemoryValues(addr, 1, numBytes)[0];
  }

  function num2hex(num) {
    let width = (is64bit()) ? 16 : 8;
    let fmt = "0".repeat(width)
    return (fmt + (+num).toString(16)).substr(-1 * width);
  }

  // --------------------------------------------------------------------------
  // module routine
  // --------------------------------------------------------------------------

  // >>> get PEB from pesudo-register
  let _peb = host.namespace.Debugger.State.PseudoRegisters.General.peb;

  // >>> create an iterator for PEB->Ldr->InLoadOrderModuleList
  // https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb
  // https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data
  let _modules = host.namespace.Debugger.Utility.Collections.FromListEntry(
    _peb.Ldr.InLoadOrderModuleList,
    "ntdll!_LDR_DATA_TABLE_ENTRY",
    "InLoadOrderLinks"
  );

  // >>> loop through each module and pull out the required fields
  for (let _dll of _modules) {

    // >>> get _IMAGE_DOS_HEADER.e_lfanew offset to _IMAGE_NT_HEADERS:
    // >>> NOTE: offset does not change 32 vs 64 bit
    // dt ntdll!_IMAGE_DOS_HEADER
    //    ...
    //    +0x03c e_lfanew       : Int4B
    let _e_lfanew = readMemory(_dll.DllBase.address + 0x3c, 4);

    // >>> get ntdll!_IMAGE_NT_HEADERS.OptionalHeader address:
    // >>> NOTE: offset does not change 32 vs 64 bit
    // dt ntdll!_IMAGE_NT_HEADERS
    //    ...
    //    +0x018 OptionalHeader : _IMAGE_OPTIONAL_HEADER
    let _OptionalHeaderAddress = _dll.DllBase.address + _e_lfanew + 0x18;

    // >>> get ntdll!_IMAGE_OPTIONAL_HEADER.DllCharacteristics:
    // >>> NOTE: offset does not change 32 vs 64 bit
    // dt ntdll!_IMAGE_OPTIONAL_HEADER
    //    ...
    //    +0x042 DllCharacteristics : Uint2B
    let _DllCharacteristics = readMemory(_OptionalHeaderAddress + 0x46, 2);

    // >>> check for DEP/ASLR/CFG/NO_SEH
    // >>> https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#dll-characteristics
    let ASLR = (_DllCharacteristics & 0x0040) ? "Yes":"No";
    let CFG  = (_DllCharacteristics & 0x0080) ? "Yes":"No";
    let DEP  = (_DllCharacteristics & 0x0100) ? "Yes":"No";
    let SEH  = (!(_DllCharacteristics & 0x0400)) ? "Yes":"No"; // NO_SEH = 1 means there is no SEH

    // >>> get offset into _IMAGE_DATA_DIRECTORY[10] for the Load Configuration RVA
    // >>> https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only
    // >>> NOTE: offsets change depending on 64 vs 32 bit, but sizeof(_IMAGE_DATA_DIRECTORY) is the same!
    // dt ntdll!_IMAGE_OPTIONAL_HEADER
    //    ...
    //    +0x060 DataDirectory      : [16] _IMAGE_DATA_DIRECTORY
    // dt ntdll!_IMAGE_OPTIONAL_HEADER64
    //    ...
    //    +0x070 DataDirectory      : [16] _IMAGE_DATA_DIRECTORY
    // ?? sizeof(_IMAGE_DATA_DIRECTORY)
    // unsigned int 8
    let _DataDirectoryAddress = (is64bit()) ? (_OptionalHeaderAddress + 0x70) : (_OptionalHeaderAddress + 0x60);
    let _loadConfigRVA = readMemory(_DataDirectoryAddress + (8 * 10), 4);

    // >>> if the load configuration VA is 0, then there is no SAFESEH or stack cookies (GS)
    let STACK_COOKIES = "No";
    let SAFE_SEH = (is64bit()) ? "N/A" : "No"; // SAFESEH is only for 32 bit images
    if (_loadConfigRVA) {
      let _loadConfigAddress = _dll.DllBase.address + _loadConfigRVA;
      // >>> https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-load-configuration-structure-image-only
      if (is64bit()) {
        SAFE_SEH = "N/A"; // SAFESEH is only for 32 bit images
        STACK_COOKIES = (readMemory(_loadConfigAddress + 88, 8)) ? "Yes" : "No";
      } else {
        STACK_COOKIES = (readMemory(_loadConfigAddress + 60, 4)) ? "Yes" : "No";
        SAFE_SEH = ((SEH === "Yes") && readMemory(_loadConfigAddress + 64, 4)) ? "Yes" : "No";
      }
    }

    // >>> return the column info for this module to be displayed
    yield {
      "BASE" : "0x" + num2hex(_dll.DllBase.address),
      "SIZE" : "0x" + num2hex(_dll.SizeOfImage),
      "ASLR" : ASLR,
      "DEP" : DEP,
      "STACK COOKIES" : STACK_COOKIES,
      "SEH" : SEH,
      "SAFE SEH": SAFE_SEH,
      "CFG" : CFG,
      "PATH" : host.memory.readWideString(_dll.FullDllName.Buffer.address),
    };
  }
}

function initializeScript() {
  log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
  log("[+] loading module ...");
  var _cmds = [
    new host.functionAlias(
      CheckSec,
      "checksec"
    ),
  ]; 
  log("[+] run module as follows:\n");
  log("dx -g @$checksec()\n");
  log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
  return _cmds;
}
